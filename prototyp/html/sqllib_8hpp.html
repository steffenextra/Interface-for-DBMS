<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SQL-Library: sqllib.hpp-Dateireferenz</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SQL-Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Suchen');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Suchen');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sqllib_8hpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">sqllib.hpp-Dateireferenz</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;string&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &quot;<a class="el" href="connection_8hpp_source.html">connection.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="database_8hpp_source.html">database.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tables_8hpp_source.html">tables.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="entry_8hpp_source.html">entry.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="selection_request_8hpp_source.html">selectionRequest.hpp</a>&quot;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include-Abhängigkeitsdiagramm für sqllib.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp__incl.png" border="0" usemap="#sqllib_8hpp" alt=""/></div>
<map name="sqllib_8hpp" id="sqllib_8hpp">
<area shape="rect" id="node7" href="connection_8hpp.html" title="connection.hpp" alt="" coords="480,152,592,177"/>
<area shape="rect" id="node8" href="database_8hpp.html" title="database.hpp" alt="" coords="153,79,255,104"/>
<area shape="rect" id="node10" href="tables_8hpp.html" title="tables.hpp" alt="" coords="517,79,600,104"/>
<area shape="rect" id="node12" href="entry_8hpp.html" title="entry.hpp" alt="" coords="724,79,800,104"/>
<area shape="rect" id="node13" href="selection_request_8hpp.html" title="selectionRequest.hpp" alt="" coords="344,79,493,104"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
Dieser Graph zeigt, welche Datei direkt oder indirekt diese Datei enthält:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp__dep__incl.png" border="0" usemap="#sqllib_8hppdep" alt=""/></div>
<map name="sqllib_8hppdep" id="sqllib_8hppdep">
<area shape="rect" id="node2" href="gui_8cpp.html" title="gui.cpp" alt="" coords="5,79,70,104"/>
<area shape="rect" id="node3" href="main_8cpp.html" title="main.cpp" alt="" coords="93,79,169,104"/>
</map>
</div>
</div>
<p><a href="sqllib_8hpp_source.html">gehe zum Quellcode dieser Datei</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:a33fd832a9e1a27bddb7d9837a2dcf2f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1">check_error</a> (void)</td></tr>
<tr class="memdesc:a33fd832a9e1a27bddb7d9837a2dcf2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fehlermethode.  <a href="#a33fd832a9e1a27bddb7d9837a2dcf2f1">Mehr ...</a><br /></td></tr>
<tr class="separator:a33fd832a9e1a27bddb7d9837a2dcf2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a404eefae07281e8d1273ca3fc447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#ab12a404eefae07281e8d1273ca3fc447">connection_feedback</a> (std::string sqlCommand)</td></tr>
<tr class="memdesc:ab12a404eefae07281e8d1273ca3fc447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rückgabe einzelner Ergebnisse.  <a href="#ab12a404eefae07281e8d1273ca3fc447">Mehr ...</a><br /></td></tr>
<tr class="separator:ab12a404eefae07281e8d1273ca3fc447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d389dd4406da88cf16f7736e012537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a83d389dd4406da88cf16f7736e012537">connection_query</a> (std::string sqlcommand)</td></tr>
<tr class="memdesc:a83d389dd4406da88cf16f7736e012537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sendet eine Abfrage zum SQL-Server.  <a href="#a83d389dd4406da88cf16f7736e012537">Mehr ...</a><br /></td></tr>
<tr class="separator:a83d389dd4406da88cf16f7736e012537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ac4f4e873cad05bcaa10a8b7e048ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a76ac4f4e873cad05bcaa10a8b7e048ce">connectionless</a> (const char *host, const char *user, const char *passwort, const char *db, unsigned int port, const char *unix_socket, unsigned int client_flag)</td></tr>
<tr class="separator:a76ac4f4e873cad05bcaa10a8b7e048ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960705de531a20389fb29928d43258c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a960705de531a20389fb29928d43258c3">disconnect</a> ()</td></tr>
<tr class="memdesc:a960705de531a20389fb29928d43258c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbindung schließen.  <a href="#a960705de531a20389fb29928d43258c3">Mehr ...</a><br /></td></tr>
<tr class="separator:a960705de531a20389fb29928d43258c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf48eb274e662a7de3f5f190d126b765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#abf48eb274e662a7de3f5f190d126b765">createDatabase</a> (std::string databaseName)</td></tr>
<tr class="memdesc:abf48eb274e662a7de3f5f190d126b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erstellen einer Datenbank.  <a href="#abf48eb274e662a7de3f5f190d126b765">Mehr ...</a><br /></td></tr>
<tr class="separator:abf48eb274e662a7de3f5f190d126b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812cc82c697df37c6a8a482f85972b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a812cc82c697df37c6a8a482f85972b4b">showDatabases</a> ()</td></tr>
<tr class="memdesc:a812cc82c697df37c6a8a482f85972b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzeigen der Datenbanken.  <a href="#a812cc82c697df37c6a8a482f85972b4b">Mehr ...</a><br /></td></tr>
<tr class="separator:a812cc82c697df37c6a8a482f85972b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0659d93a42f84756e52155eb333c4fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a0659d93a42f84756e52155eb333c4fec">renameDatabase</a> (std::string databaseName, std::string newDatabaseName)</td></tr>
<tr class="memdesc:a0659d93a42f84756e52155eb333c4fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datenbanknamen ändern.  <a href="#a0659d93a42f84756e52155eb333c4fec">Mehr ...</a><br /></td></tr>
<tr class="separator:a0659d93a42f84756e52155eb333c4fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1fac4a7c1506f81908532050a8e58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a1d1fac4a7c1506f81908532050a8e58f">deleteDatabase</a> (std::string databaseName)</td></tr>
<tr class="memdesc:a1d1fac4a7c1506f81908532050a8e58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen einer Datenbank.  <a href="#a1d1fac4a7c1506f81908532050a8e58f">Mehr ...</a><br /></td></tr>
<tr class="separator:a1d1fac4a7c1506f81908532050a8e58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018659fc814b4a097c4b4862f42fe554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a018659fc814b4a097c4b4862f42fe554">createTable</a> (bool primary_key, std::string tableName, std::vector&lt; std::string &gt; columns)</td></tr>
<tr class="separator:a018659fc814b4a097c4b4862f42fe554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fbeb7f18a00bafd4864de51a3bca28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a22fbeb7f18a00bafd4864de51a3bca28">showTable</a> (std::string tableName)</td></tr>
<tr class="memdesc:a22fbeb7f18a00bafd4864de51a3bca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ausgabe der Tabelle.  <a href="#a22fbeb7f18a00bafd4864de51a3bca28">Mehr ...</a><br /></td></tr>
<tr class="separator:a22fbeb7f18a00bafd4864de51a3bca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526b049a888b2a4a1332a10540689afd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a526b049a888b2a4a1332a10540689afd">renameTable</a> (std::string tablename, std::string newTableName)</td></tr>
<tr class="memdesc:a526b049a888b2a4a1332a10540689afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Änderung des Tabellennamens.  <a href="#a526b049a888b2a4a1332a10540689afd">Mehr ...</a><br /></td></tr>
<tr class="separator:a526b049a888b2a4a1332a10540689afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754762b2c19711bf3dcbfceca61d97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a9754762b2c19711bf3dcbfceca61d97d">deleteTable</a> (std::string tableName)</td></tr>
<tr class="memdesc:a9754762b2c19711bf3dcbfceca61d97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen einer Tabelle.  <a href="#a9754762b2c19711bf3dcbfceca61d97d">Mehr ...</a><br /></td></tr>
<tr class="separator:a9754762b2c19711bf3dcbfceca61d97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4575b6ed6eb203c2796930c41ed555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a7c4575b6ed6eb203c2796930c41ed555">setColumn</a> (std::string tableName, std::string ColumnName, std::string datatype)</td></tr>
<tr class="memdesc:a7c4575b6ed6eb203c2796930c41ed555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bearbeiten der Spalte in einer Tabelle.  <a href="#a7c4575b6ed6eb203c2796930c41ed555">Mehr ...</a><br /></td></tr>
<tr class="separator:a7c4575b6ed6eb203c2796930c41ed555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4605e656585a77253f0940725b97ad04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a4605e656585a77253f0940725b97ad04">setColumnWithPrimary</a> (std::string tableName, std::string ColumnName, std::string datatype, bool autoinc)</td></tr>
<tr class="memdesc:a4605e656585a77253f0940725b97ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setzen des Primärschlüssels.  <a href="#a4605e656585a77253f0940725b97ad04">Mehr ...</a><br /></td></tr>
<tr class="separator:a4605e656585a77253f0940725b97ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244b10b3b373f8a174943176101a480f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a244b10b3b373f8a174943176101a480f">modifierColumnName</a> (std::string tableName, std::string oldColumnName, std::string newColumnName, std::string datatype)</td></tr>
<tr class="memdesc:a244b10b3b373f8a174943176101a480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifizieren des Spaltennamens.  <a href="#a244b10b3b373f8a174943176101a480f">Mehr ...</a><br /></td></tr>
<tr class="separator:a244b10b3b373f8a174943176101a480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4d6b8ba9c38e5f1b459694421ad9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aef4d6b8ba9c38e5f1b459694421ad9e5">changeTheDatatype</a> (std::string tableName, std::string columnName, std::string datatype)</td></tr>
<tr class="memdesc:aef4d6b8ba9c38e5f1b459694421ad9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ändern des Datentyps.  <a href="#aef4d6b8ba9c38e5f1b459694421ad9e5">Mehr ...</a><br /></td></tr>
<tr class="separator:aef4d6b8ba9c38e5f1b459694421ad9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb780082d3f7392e485cac394d6c606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aceb780082d3f7392e485cac394d6c606">getAllColumn</a> (std::string tableName)</td></tr>
<tr class="memdesc:aceb780082d3f7392e485cac394d6c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzeigen von Spalten.  <a href="#aceb780082d3f7392e485cac394d6c606">Mehr ...</a><br /></td></tr>
<tr class="separator:aceb780082d3f7392e485cac394d6c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2178bf4577d7eea6caebd8d1c942088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#ad2178bf4577d7eea6caebd8d1c942088">countDatasets</a> (std::string tableName)</td></tr>
<tr class="memdesc:ad2178bf4577d7eea6caebd8d1c942088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zählen der Datensätze.  <a href="#ad2178bf4577d7eea6caebd8d1c942088">Mehr ...</a><br /></td></tr>
<tr class="separator:ad2178bf4577d7eea6caebd8d1c942088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc31570307c41c7327c3da4886ae7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#addc31570307c41c7327c3da4886ae7bf">showColumnTyp</a> (std::string tableName, std::string datatype)</td></tr>
<tr class="memdesc:addc31570307c41c7327c3da4886ae7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datentyp der Spalte anzeigen lassen.  <a href="#addc31570307c41c7327c3da4886ae7bf">Mehr ...</a><br /></td></tr>
<tr class="separator:addc31570307c41c7327c3da4886ae7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b10ab46a5fb3caa76745e084685e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aa3b10ab46a5fb3caa76745e084685e76">deleteColumn</a> (std::string tableName, std::string columnName)</td></tr>
<tr class="memdesc:aa3b10ab46a5fb3caa76745e084685e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen von Spalten.  <a href="#aa3b10ab46a5fb3caa76745e084685e76">Mehr ...</a><br /></td></tr>
<tr class="separator:aa3b10ab46a5fb3caa76745e084685e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca01f302c4488d661196653d8f6c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a4aca01f302c4488d661196653d8f6c28">setSecondaryKey</a> (std::string tableNameSecondary, std::string foreignKey, std::string tableNamePrimary, std::string primaryKey, std::string constraint)</td></tr>
<tr class="memdesc:a4aca01f302c4488d661196653d8f6c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setzen des Sekundärschlüssels (Foreign Key)  <a href="#a4aca01f302c4488d661196653d8f6c28">Mehr ...</a><br /></td></tr>
<tr class="separator:a4aca01f302c4488d661196653d8f6c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee892818f06208ce4b68fb7598a7494c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aee892818f06208ce4b68fb7598a7494c">deleteSecondaryKey</a> (std::string tableName, std::string constraint)</td></tr>
<tr class="memdesc:aee892818f06208ce4b68fb7598a7494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen des Sekundärschlüssels.  <a href="#aee892818f06208ce4b68fb7598a7494c">Mehr ...</a><br /></td></tr>
<tr class="separator:aee892818f06208ce4b68fb7598a7494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2797835afcf68b73ba522e7bb91f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aac2797835afcf68b73ba522e7bb91f5f">setPrimaryKey</a> (std::string tableName, std::string primaryKey)</td></tr>
<tr class="memdesc:aac2797835afcf68b73ba522e7bb91f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nachträgliches setzen eines Primärschlüssels.  <a href="#aac2797835afcf68b73ba522e7bb91f5f">Mehr ...</a><br /></td></tr>
<tr class="separator:aac2797835afcf68b73ba522e7bb91f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d0f9bb1b86a8155d7551fcd014b4da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a36d0f9bb1b86a8155d7551fcd014b4da">deletePrimaryKey</a> (std::string tableName)</td></tr>
<tr class="memdesc:a36d0f9bb1b86a8155d7551fcd014b4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen des Primärschlüssels.  <a href="#a36d0f9bb1b86a8155d7551fcd014b4da">Mehr ...</a><br /></td></tr>
<tr class="separator:a36d0f9bb1b86a8155d7551fcd014b4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faab165d9a7dc43808e1a0075e007f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a1faab165d9a7dc43808e1a0075e007f9">setEntry</a> (std::string tableName, std::string columnName, std::string entry)</td></tr>
<tr class="memdesc:a1faab165d9a7dc43808e1a0075e007f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erstellen eines Eintrags.  <a href="#a1faab165d9a7dc43808e1a0075e007f9">Mehr ...</a><br /></td></tr>
<tr class="separator:a1faab165d9a7dc43808e1a0075e007f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab254b5514a4950c7479bc4d513c438dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#ab254b5514a4950c7479bc4d513c438dc">modifierEntry</a> (std::string tableName, std::string columnName, std::string oldEntry, std::string newEntry)</td></tr>
<tr class="memdesc:ab254b5514a4950c7479bc4d513c438dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Einträge modifizieren.  <a href="#ab254b5514a4950c7479bc4d513c438dc">Mehr ...</a><br /></td></tr>
<tr class="separator:ab254b5514a4950c7479bc4d513c438dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb45ccd70b8692b592754a0886c2d109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aeb45ccd70b8692b592754a0886c2d109">setAllEntry</a> (std::string tableName, std::vector&lt; std::string &gt; <a class="el" href="connection_8cpp.html#a34269e7c6df16f7d1b6034b9fce28463">row</a>)</td></tr>
<tr class="memdesc:aeb45ccd70b8692b592754a0886c2d109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beliebige Anzahl von Einträgen hinzufügen.  <a href="#aeb45ccd70b8692b592754a0886c2d109">Mehr ...</a><br /></td></tr>
<tr class="separator:aeb45ccd70b8692b592754a0886c2d109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea4c59c6377c754fd0264b58f476685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a1ea4c59c6377c754fd0264b58f476685">deleteEntry</a> (std::string tableName, std::string columnName, std::string condition)</td></tr>
<tr class="memdesc:a1ea4c59c6377c754fd0264b58f476685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Löschen von Einträgen.  <a href="#a1ea4c59c6377c754fd0264b58f476685">Mehr ...</a><br /></td></tr>
<tr class="separator:a1ea4c59c6377c754fd0264b58f476685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a1909c1b8666cf6e3d31a014c9a9ad2d7">ownCommand</a> (std::string sqlCommand, std::string commandType)</td></tr>
<tr class="memdesc:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Benutzereigener SQL-Befehl.  <a href="#a1909c1b8666cf6e3d31a014c9a9ad2d7">Mehr ...</a><br /></td></tr>
<tr class="separator:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ced4bb0e929e97740616c59374d992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a80ced4bb0e929e97740616c59374d992">selectLike</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string toSearchColumn, std::string pattern, std::string toSearch)</td></tr>
<tr class="memdesc:a80ced4bb0e929e97740616c59374d992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suche nach Muster.  <a href="#a80ced4bb0e929e97740616c59374d992">Mehr ...</a><br /></td></tr>
<tr class="separator:a80ced4bb0e929e97740616c59374d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aab8b32ae4ac6aeddc5c05578b4c79ace">selectNotLike</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string toSearchColumn, std::string pattern, std::string toSearch)</td></tr>
<tr class="memdesc:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suche nach Muster.  <a href="#aab8b32ae4ac6aeddc5c05578b4c79ace">Mehr ...</a><br /></td></tr>
<tr class="separator:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c9217024bfe521a229e0b4162e5ef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#ae4c9217024bfe521a229e0b4162e5ef7">selectMinOrMax</a> (std::string tableName, std::string minOrMax, std::string minOrMaxColumn, std::string aliasColumn)</td></tr>
<tr class="memdesc:ae4c9217024bfe521a229e0b4162e5ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ermittlung des höchsten / niedrigsten Wertes.  <a href="#ae4c9217024bfe521a229e0b4162e5ef7">Mehr ...</a><br /></td></tr>
<tr class="separator:ae4c9217024bfe521a229e0b4162e5ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f437d3c3c841e8a82b9ad1b514007e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a39f437d3c3c841e8a82b9ad1b514007e">selectMinOrMaxWhere</a> (std::string tableName, std::string minOrMax, std::string minOrMaxColumn, std::string aliasColumn, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a39f437d3c3c841e8a82b9ad1b514007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Höchster / niedrigster Wert mit Bedingung und Alias-Spalte.  <a href="#a39f437d3c3c841e8a82b9ad1b514007e">Mehr ...</a><br /></td></tr>
<tr class="separator:a39f437d3c3c841e8a82b9ad1b514007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a94c57cf58c1b2812e3d1ce9b3837286d">selectLimitWhereOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string limitNumber, std::string conditionColumn, std::string conditionValue, std::string toSortColumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bestimmte Anzahl von Datensätzen mit Bedingung abfragen.  <a href="#a94c57cf58c1b2812e3d1ce9b3837286d">Mehr ...</a><br /></td></tr>
<tr class="separator:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519933061d4010c3a8d743b7e9fa9939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a519933061d4010c3a8d743b7e9fa9939">selectWhereOneColumn</a> (std::string tableName, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a519933061d4010c3a8d743b7e9fa9939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bestimmte Datensätze von bestimmten Spalten abfragen.  <a href="#a519933061d4010c3a8d743b7e9fa9939">Mehr ...</a><br /></td></tr>
<tr class="separator:a519933061d4010c3a8d743b7e9fa9939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb635de3f1856a45557b42f18eff28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a90eb635de3f1856a45557b42f18eff28">selectWhere</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a90eb635de3f1856a45557b42f18eff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzeigen bestimmter Datensätze mit dem Zusatz der Where-Clause.  <a href="#a90eb635de3f1856a45557b42f18eff28">Mehr ...</a><br /></td></tr>
<tr class="separator:a90eb635de3f1856a45557b42f18eff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c986e9aa0e2d7e080ba5eb294a1182e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a0c986e9aa0e2d7e080ba5eb294a1182e">selectWhereBool</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::vector&lt; std::string &gt;conditions, std::vector&lt; std::string &gt;conditionValue, std::vector&lt; std::string &gt; conditions2, std::vector&lt; std::string &gt;conditionValue2, std::vector&lt; std::string &gt;operators)</td></tr>
<tr class="separator:a0c986e9aa0e2d7e080ba5eb294a1182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94269766ff6e39ba8a38f5623314c3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a94269766ff6e39ba8a38f5623314c3cd">selectWhereOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string conditionColumn, std::string conditionValue, std::string toSortcolumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a94269766ff6e39ba8a38f5623314c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abfrage von Spalten mit Sortierung.  <a href="#a94269766ff6e39ba8a38f5623314c3cd">Mehr ...</a><br /></td></tr>
<tr class="separator:a94269766ff6e39ba8a38f5623314c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a41ec41130fdce3f2c4dd701438f26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a6a41ec41130fdce3f2c4dd701438f26a">selectSortTable</a> (std::string tableName, std::string toSortColumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a6a41ec41130fdce3f2c4dd701438f26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabelle wird nach Angabe sortiert.  <a href="#a6a41ec41130fdce3f2c4dd701438f26a">Mehr ...</a><br /></td></tr>
<tr class="separator:a6a41ec41130fdce3f2c4dd701438f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f071477f164f70927ee9923dd77a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a00f071477f164f70927ee9923dd77a39">selectCount</a> (std::string tableName, std::string countColumn, std::string aliasColumnName)</td></tr>
<tr class="memdesc:a00f071477f164f70927ee9923dd77a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzahl von ausgewählten Datensätzen.  <a href="#a00f071477f164f70927ee9923dd77a39">Mehr ...</a><br /></td></tr>
<tr class="separator:a00f071477f164f70927ee9923dd77a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba13caf613af9f91f2a2f1a8f9d49967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aba13caf613af9f91f2a2f1a8f9d49967">selectDistinct</a> (std::string tableName, std::vector&lt; std::string &gt; columns)</td></tr>
<tr class="memdesc:aba13caf613af9f91f2a2f1a8f9d49967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redundanzen werden eliminiert und nur einmal angezeigt.  <a href="#aba13caf613af9f91f2a2f1a8f9d49967">Mehr ...</a><br /></td></tr>
<tr class="separator:aba13caf613af9f91f2a2f1a8f9d49967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f770e3b1eb29fce843172c187ccc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a8d6f770e3b1eb29fce843172c187ccc6">selectCountDistinct</a> (std::string tableName, std::string countColumn)</td></tr>
<tr class="memdesc:a8d6f770e3b1eb29fce843172c187ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keine Redundanzen / Datensätze werden gezählt.  <a href="#a8d6f770e3b1eb29fce843172c187ccc6">Mehr ...</a><br /></td></tr>
<tr class="separator:a8d6f770e3b1eb29fce843172c187ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bd0062142a17ad04b7101bac7b38b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a01bd0062142a17ad04b7101bac7b38b6">selectAverageSum</a> (std::string tableName, std::string columnName)</td></tr>
<tr class="memdesc:a01bd0062142a17ad04b7101bac7b38b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Durchschnittswert.  <a href="#a01bd0062142a17ad04b7101bac7b38b6">Mehr ...</a><br /></td></tr>
<tr class="separator:a01bd0062142a17ad04b7101bac7b38b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a9f37b58ba921dc5e6b5d4a5d0fefe28e">selectSum</a> (std::string tableName, std::string columnName, std::string aliasColumnName)</td></tr>
<tr class="memdesc:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summieren von Werten.  <a href="#a9f37b58ba921dc5e6b5d4a5d0fefe28e">Mehr ...</a><br /></td></tr>
<tr class="separator:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a1bde570da9c90a3d0f6e94bc1b06c5e3">unionSelect</a> (std::vector&lt; std::string &gt; tableName, std::vector&lt; std::string &gt; columnName)</td></tr>
<tr class="memdesc:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vereinigung zweier Abfragen.  <a href="#a1bde570da9c90a3d0f6e94bc1b06c5e3">Mehr ...</a><br /></td></tr>
<tr class="separator:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#ac3a0a9620e1b5ac8c90104b1daea4f5f">selectIn</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string searchInColumn, std::vector&lt; std::string &gt;conditionValue)</td></tr>
<tr class="memdesc:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mehrere Abfrageergebnisse bündeln.  <a href="#ac3a0a9620e1b5ac8c90104b1daea4f5f">Mehr ...</a><br /></td></tr>
<tr class="separator:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aaa15591ca7a3ba5d40fa77b7ae6753db">selectBetween</a> (std::string conditionString, std::string conditionStringTwo, std::string tableName, std::string conditionColumn, std::string conditionColumnTwo, std::string condition, std::string conditionTwo)</td></tr>
<tr class="memdesc:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eingeschränkte Abfragen.  <a href="#aaa15591ca7a3ba5d40fa77b7ae6753db">Mehr ...</a><br /></td></tr>
<tr class="separator:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd3f475ec96949ae94bbbbec41f7725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a0bd3f475ec96949ae94bbbbec41f7725">selectColumnsAlias</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::vector&lt; std::string &gt;aliases)</td></tr>
<tr class="memdesc:a0bd3f475ec96949ae94bbbbec41f7725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias-Spaltennamen.  <a href="#a0bd3f475ec96949ae94bbbbec41f7725">Mehr ...</a><br /></td></tr>
<tr class="separator:a0bd3f475ec96949ae94bbbbec41f7725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a3ac5ebbcfb624dc5178315c85c4b15fa">selectTableAlias</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string aliasTableName)</td></tr>
<tr class="memdesc:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zuweisung eines Alias.  <a href="#a3ac5ebbcfb624dc5178315c85c4b15fa">Mehr ...</a><br /></td></tr>
<tr class="separator:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c70afd3e6ad75085ddf6aff29abe87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a54c70afd3e6ad75085ddf6aff29abe87">selectGroupBy</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns)</td></tr>
<tr class="memdesc:a54c70afd3e6ad75085ddf6aff29abe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gruppieren von Ergebnismengen.  <a href="#a54c70afd3e6ad75085ddf6aff29abe87">Mehr ...</a><br /></td></tr>
<tr class="separator:a54c70afd3e6ad75085ddf6aff29abe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e60ce2e53b91725f89c66539e5bd73d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a5e60ce2e53b91725f89c66539e5bd73d">selectGroupByOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns, std::string toSortcolumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a5e60ce2e53b91725f89c66539e5bd73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ergebnismengen + sortieren.  <a href="#a5e60ce2e53b91725f89c66539e5bd73d">Mehr ...</a><br /></td></tr>
<tr class="separator:a5e60ce2e53b91725f89c66539e5bd73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a851bc3e6b04b4dfaa359b43534a37cd5">selectCountGroupByOrderBy</a> (std::string tableName, std::string countColumn, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns, std::string sortBy)</td></tr>
<tr class="memdesc:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ergebnismengen gruppieren + zählen der Datensätze + Sortierung.  <a href="#a851bc3e6b04b4dfaa359b43534a37cd5">Mehr ...</a><br /></td></tr>
<tr class="separator:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcd1503abb6715de26a92d34714dcce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aedcd1503abb6715de26a92d34714dcce">selectNull</a> (std::string tableName, std::string columnName)</td></tr>
<tr class="memdesc:aedcd1503abb6715de26a92d34714dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL Werte.  <a href="#aedcd1503abb6715de26a92d34714dcce">Mehr ...</a><br /></td></tr>
<tr class="separator:aedcd1503abb6715de26a92d34714dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aa0d6684a1d4f8e82d699b713e38c9d44">selectInnerJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">InnerJoin-Befehl.  <a href="#aa0d6684a1d4f8e82d699b713e38c9d44">Mehr ...</a><br /></td></tr>
<tr class="separator:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">selectLeftJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LeftJoin Methode.  <a href="#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">Mehr ...</a><br /></td></tr>
<tr class="separator:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2cca0ae3f40a8b3ec70e85702bb8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#aff2cca0ae3f40a8b3ec70e85702bb8fc">selectRightJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="separator:aff2cca0ae3f40a8b3ec70e85702bb8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41392b97718c999af4867dc0c62ade0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sqllib_8hpp.html#a41392b97718c999af4867dc0c62ade0c">selectFullJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:a41392b97718c999af4867dc0c62ade0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">FullJoin Methode.  <a href="#a41392b97718c999af4867dc0c62ade0c">Mehr ...</a><br /></td></tr>
<tr class="separator:a41392b97718c999af4867dc0c62ade0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a id="aef4d6b8ba9c38e5f1b459694421ad9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4d6b8ba9c38e5f1b459694421ad9e5">&#9670;&nbsp;</a></span>changeTheDatatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void changeTheDatatype </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>datatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ändern des Datentyps. </p>
<p>Ändern des Datentyps einer Spalte ohne den Namen der Spalte zu ändern. <br />
 Wenn der Datentyp der Spalte geändert wird, muss darauf geachtet werden, dass die Objekte in der Spalte dem Datentyp entsprechen. <br />
</p>
<p>SQL-Befehl: "AlTER TABLE " + tableName + " MODIFY " + columnName + " " + datatype;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Name der Spalte </td></tr>
    <tr><td class="paramname">datatype</td><td>= Neuer Datentyp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a33fd832a9e1a27bddb7d9837a2dcf2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fd832a9e1a27bddb7d9837a2dcf2f1">&#9670;&nbsp;</a></span>check_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fehlermethode. </p>
<p>!</p>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This is the introduction.</p>
<h1><a class="anchor" id="install"></a>
Installation</h1>
<h2><a class="anchor" id="step1"></a>
Step 1: Opening the box</h2>
<p>etc...</p>
<p>Die Methode "check_error" ist verantwortlich für die Ausnahme, die ausgelöst wird, wenn MySQL einen Fehler zurückgibt.<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>

</div>
</div>
<a id="ab12a404eefae07281e8d1273ca3fc447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12a404eefae07281e8d1273ca3fc447">&#9670;&nbsp;</a></span>connection_feedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_feedback </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sqlCommand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rückgabe einzelner Ergebnisse. </p>
<p>Die Methode "connection_feedback" liefert eine Spalte des aktuellen Datensatzes.<br />
 Diese wird benutzt um einzelne Ergebnis zurückzugeben. (Bspw. <a class="el" href="selection_request_8cpp.html#a00f071477f164f70927ee9923dd77a39" title="Anzahl von ausgewählten Datensätzen. ">selectCount()</a> )</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">sqlCommand</td><td>= enthält den auszuführenden SQL-Befehl</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_cgraph.png" border="0" usemap="#sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_cgraph" alt=""/></div>
<map name="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_cgraph" id="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="201,5,292,31"/>
</map>
</div>
<div class="dynheader">
Hier ist ein Graph der zeigt, wo diese Funktion aufgerufen wird:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_icgraph.png" border="0" usemap="#sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_icgraph" alt=""/></div>
<map name="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_icgraph" id="sqllib_8hpp_ab12a404eefae07281e8d1273ca3fc447_icgraph">
<area shape="rect" id="node2" href="sqllib_8hpp.html#a812cc82c697df37c6a8a482f85972b4b" title="Anzeigen der Datenbanken. " alt="" coords="226,5,342,31"/>
<area shape="rect" id="node3" href="sqllib_8hpp.html#a1909c1b8666cf6e3d31a014c9a9ad2d7" title="Benutzereigener SQL&#45;Befehl. " alt="" coords="230,55,338,80"/>
<area shape="rect" id="node4" href="sqllib_8hpp.html#a519933061d4010c3a8d743b7e9fa9939" title="Bestimmte Datensätze von bestimmten Spalten abfragen. " alt="" coords="201,104,367,129"/>
<area shape="rect" id="node5" href="sqllib_8hpp.html#a6a41ec41130fdce3f2c4dd701438f26a" title="Tabelle wird nach Angabe sortiert. " alt="" coords="228,153,340,179"/>
<area shape="rect" id="node6" href="sqllib_8hpp.html#a8d6f770e3b1eb29fce843172c187ccc6" title="Keine Redundanzen / Datensätze werden gezählt. " alt="" coords="216,203,352,228"/>
<area shape="rect" id="node7" href="sqllib_8hpp.html#a01bd0062142a17ad04b7101bac7b38b6" title="Durchschnittswert. " alt="" coords="217,252,350,277"/>
<area shape="rect" id="node8" href="tables_8hpp.html#aceb780082d3f7392e485cac394d6c606" title="Anzeigen von Spalten. " alt="" coords="234,301,334,327"/>
<area shape="rect" id="node9" href="tables_8hpp.html#ad2178bf4577d7eea6caebd8d1c942088" title="Zählen der Datensätze. " alt="" coords="231,351,337,376"/>
</map>
</div>

</div>
</div>
<a id="a83d389dd4406da88cf16f7736e012537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d389dd4406da88cf16f7736e012537">&#9670;&nbsp;</a></span>connection_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_query </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sqlCommand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sendet eine Abfrage zum SQL-Server. </p>
<p>Die Methode "connection_query" sendet eine eindeutige Abfrage (mehrere Abfragen werden nicht unterstützt) an die derzeit aktive Datenbank auf dem Server, der dem angegebenen Server zugeordnet ist. <br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">sqlCommand</td><td>= enhält den auszuführenden SQL-Befehl</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_cgraph.png" border="0" usemap="#sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_cgraph" id="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="180,5,272,31"/>
</map>
</div>
<div class="dynheader">
Hier ist ein Graph der zeigt, wo diese Funktion aufgerufen wird:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_icgraph.png" border="0" usemap="#sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_icgraph" alt=""/></div>
<map name="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_icgraph" id="sqllib_8hpp_a83d389dd4406da88cf16f7736e012537_icgraph">
<area shape="rect" id="node2" href="sqllib_8hpp.html#abf48eb274e662a7de3f5f190d126b765" title="Erstellen einer Datenbank. " alt="" coords="201,5,316,31"/>
<area shape="rect" id="node3" href="sqllib_8hpp.html#a0659d93a42f84756e52155eb333c4fec" title="Datenbanknamen ändern. " alt="" coords="197,55,321,80"/>
<area shape="rect" id="node4" href="sqllib_8hpp.html#a1d1fac4a7c1506f81908532050a8e58f" title="Löschen einer Datenbank. " alt="" coords="201,104,316,129"/>
<area shape="rect" id="node5" href="sqllib_8hpp.html#a1faab165d9a7dc43808e1a0075e007f9" title="Erstellen eines Eintrags. " alt="" coords="224,153,294,179"/>
<area shape="rect" id="node6" href="sqllib_8hpp.html#ab254b5514a4950c7479bc4d513c438dc" title="Einträge modifizieren. " alt="" coords="209,203,309,228"/>
<area shape="rect" id="node7" href="sqllib_8hpp.html#aeb45ccd70b8692b592754a0886c2d109" title="Beliebige Anzahl von Einträgen hinzufügen. " alt="" coords="216,252,301,277"/>
<area shape="rect" id="node8" href="sqllib_8hpp.html#a1ea4c59c6377c754fd0264b58f476685" title="Löschen von Einträgen. " alt="" coords="214,301,303,327"/>
<area shape="rect" id="node9" href="sqllib_8hpp.html#a1909c1b8666cf6e3d31a014c9a9ad2d7" title="Benutzereigener SQL&#45;Befehl. " alt="" coords="205,351,312,376"/>
<area shape="rect" id="node10" href="tables_8cpp.html#a6bd46ec08e83f28ae60e1d235d9d2659" title="Erstellen einer Tabelle. " alt="" coords="413,476,503,501"/>
<area shape="rect" id="node11" href="tables_8hpp.html#a526b049a888b2a4a1332a10540689afd" title="Änderung des Tabellennamens. " alt="" coords="210,452,308,477"/>
<area shape="rect" id="node12" href="tables_8hpp.html#a9754762b2c19711bf3dcbfceca61d97d" title="Löschen einer Tabelle. " alt="" coords="214,501,304,527"/>
<area shape="rect" id="node13" href="tables_8hpp.html#a7c4575b6ed6eb203c2796930c41ed555" title="Bearbeiten der Spalte in einer Tabelle. " alt="" coords="216,551,301,576"/>
<area shape="rect" id="node14" href="tables_8hpp.html#a4605e656585a77253f0940725b97ad04" title="Setzen des Primärschlüssels. " alt="" coords="180,600,338,625"/>
<area shape="rect" id="node15" href="tables_8hpp.html#a244b10b3b373f8a174943176101a480f" title="Modifizieren des Spaltennamens. " alt="" coords="184,649,334,675"/>
<area shape="rect" id="node16" href="tables_8hpp.html#aef4d6b8ba9c38e5f1b459694421ad9e5" title="Ändern des Datentyps. " alt="" coords="188,699,329,724"/>
<area shape="rect" id="node17" href="tables_8hpp.html#aa3b10ab46a5fb3caa76745e084685e76" title="Löschen von Spalten. " alt="" coords="207,748,311,773"/>
<area shape="rect" id="node18" href="tables_8hpp.html#a4aca01f302c4488d661196653d8f6c28" title="Setzen des Sekundärschlüssels (Foreign Key) " alt="" coords="196,797,322,823"/>
<area shape="rect" id="node19" href="tables_8cpp.html#ae62b61e29ea8b6010ae2463f80598460" title="Löschen der Schlüsselgruppe. " alt="" coords="200,847,318,872"/>
<area shape="rect" id="node20" href="tables_8hpp.html#aee892818f06208ce4b68fb7598a7494c" title="Löschen des Sekundärschlüssels. " alt="" coords="386,872,530,897"/>
<area shape="rect" id="node21" href="tables_8hpp.html#aac2797835afcf68b73ba522e7bb91f5f" title="Nachträgliches setzen eines Primärschlüssels. " alt="" coords="205,948,313,973"/>
<area shape="rect" id="node22" href="tables_8hpp.html#a36d0f9bb1b86a8155d7551fcd014b4da" title="Löschen des Primärschlüssels. " alt="" coords="195,997,322,1023"/>
</map>
</div>

</div>
</div>
<a id="a76ac4f4e873cad05bcaa10a8b7e048ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ac4f4e873cad05bcaa10a8b7e048ce">&#9670;&nbsp;</a></span>connectionless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connectionless </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passwort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unix_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>client_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2178bf4577d7eea6caebd8d1c942088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2178bf4577d7eea6caebd8d1c942088">&#9670;&nbsp;</a></span>countDatasets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countDatasets </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zählen der Datensätze. </p>
<p>Alle Datensätze werden gezählt und ausgegeben.<br />
</p>
<p>SQL-Befehl: "SELECT COUNT (*) FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="abf48eb274e662a7de3f5f190d126b765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf48eb274e662a7de3f5f190d126b765">&#9670;&nbsp;</a></span>createDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void createDatabase </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>databaseName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erstellen einer Datenbank. </p>
<p>Die Methode "createDatabase" sendet einen Befehl um eine Datenbank zu erstellen an den SQL Server</p>
<p>SQL-Befehl: "CREATE DATABASE " + databaseName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">databaseName</td><td>= enthält den Namen für die zu erstellende Datenbank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_abf48eb274e662a7de3f5f190d126b765_cgraph.png" border="0" usemap="#sqllib_8hpp_abf48eb274e662a7de3f5f190d126b765_cgraph" alt=""/></div>
<map name="sqllib_8hpp_abf48eb274e662a7de3f5f190d126b765_cgraph" id="sqllib_8hpp_abf48eb274e662a7de3f5f190d126b765_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="343,5,435,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="169,31,295,56"/>
</map>
</div>

</div>
</div>
<a id="a018659fc814b4a097c4b4862f42fe554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018659fc814b4a097c4b4862f42fe554">&#9670;&nbsp;</a></span>createTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void createTable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>primary_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b10ab46a5fb3caa76745e084685e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b10ab46a5fb3caa76745e084685e76">&#9670;&nbsp;</a></span>deleteColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteColumn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen von Spalten. </p>
<p>Durch die Angabe des Tabellen/- und Spaltennamens werden einzelne Spalten gelöscht.</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " DROP " + columnName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Name der Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a1d1fac4a7c1506f81908532050a8e58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1fac4a7c1506f81908532050a8e58f">&#9670;&nbsp;</a></span>deleteDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteDatabase </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>databaseName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen einer Datenbank. </p>
<p>Die Methode "deleteDatabase" senden dem Befehl eine Datenbank zu löschen.<br />
 Bis auf die gewählte Datenbank für die Connetionless Methode können alle Datenbanken ugelöscht werden.<br />
</p>
<p>SQL-Befehl: "DROP DATABASE " + databaseName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">databaseName</td><td>= enthält den Namen für die zu löschende Datenbank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a1d1fac4a7c1506f81908532050a8e58f_cgraph.png" border="0" usemap="#sqllib_8hpp_a1d1fac4a7c1506f81908532050a8e58f_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a1d1fac4a7c1506f81908532050a8e58f_cgraph" id="sqllib_8hpp_a1d1fac4a7c1506f81908532050a8e58f_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="343,5,434,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="168,31,295,56"/>
</map>
</div>

</div>
</div>
<a id="a1ea4c59c6377c754fd0264b58f476685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea4c59c6377c754fd0264b58f476685">&#9670;&nbsp;</a></span>deleteEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen von Einträgen. </p>
<p>Die Methode "deleteEntry" senden dem Befehl einen Eintrag einer Tabelle zu löschen.<br />
</p>
<p>SQL-Befehl: DELETE FROM " + tableName + " WHERE " + columnName + " = " + "'" + condition + "'";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enhält den Spaltennamen in der, der Eintrag gelöscht werden soll  = enhält den Eintrag, der gelöscht werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a1ea4c59c6377c754fd0264b58f476685_cgraph.png" border="0" usemap="#sqllib_8hpp_a1ea4c59c6377c754fd0264b58f476685_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a1ea4c59c6377c754fd0264b58f476685_cgraph" id="sqllib_8hpp_a1ea4c59c6377c754fd0264b58f476685_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="317,5,408,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="142,31,269,56"/>
</map>
</div>

</div>
</div>
<a id="a36d0f9bb1b86a8155d7551fcd014b4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d0f9bb1b86a8155d7551fcd014b4da">&#9670;&nbsp;</a></span>deletePrimaryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deletePrimaryKey </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen des Primärschlüssels. </p>
<p>Solange keine Verbindungen zu anderen Tabellen über den Primärschlüssel laufen, kann dieser ohne Probleme gelöscht werden. <br />
 In dieser Methode reicht die Übergabe des Tabellennamens, da der Primärschlüssel nicht mehr als einmal auftauchen kann. <br />
</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " DROP PRIMARY KEY";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="aee892818f06208ce4b68fb7598a7494c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee892818f06208ce4b68fb7598a7494c">&#9670;&nbsp;</a></span>deleteSecondaryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteSecondaryKey </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen des Sekundärschlüssels. </p>
<p>Der gesetzte Sekundärschlüssel im Bezug auf den gesetzten Primärschlüssel und die Schlüsselgruppe kann mit dieser Methode gelöscht werden.<br />
</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " DROP FOREIGN KEY " + constraint + "; ";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">constraint</td><td>= Name der Schlüsselgruppe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a9754762b2c19711bf3dcbfceca61d97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754762b2c19711bf3dcbfceca61d97d">&#9670;&nbsp;</a></span>deleteTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteTable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Löschen einer Tabelle. </p>
<p>Durch das Übergeben des Tabellennamens wird die angegebene Tabelle mit dessen Inhalt gelöscht.<br />
</p>
<p>SQL-Befehl: "DROP TABLE " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a960705de531a20389fb29928d43258c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960705de531a20389fb29928d43258c3">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verbindung schließen. </p>
<p>Die Methode "disconnect" setzt alle ausstehenden Transaktionen zurück. <br />
 Anschließend wird die Verbindung zum Verbindungspool freigegeben oder die Verbindung wird geschlossen, wenn das Verbindungspooling deaktiviert ist.<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph der zeigt, wo diese Funktion aufgerufen wird:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a960705de531a20389fb29928d43258c3_icgraph.png" border="0" usemap="#sqllib_8hpp_a960705de531a20389fb29928d43258c3_icgraph" alt=""/></div>
<map name="sqllib_8hpp_a960705de531a20389fb29928d43258c3_icgraph" id="sqllib_8hpp_a960705de531a20389fb29928d43258c3_icgraph">
<area shape="rect" id="node2" href="gui_8hpp.html#aa0976691d9932853389991b8459ebd85" title="whenPushed" alt="" coords="138,5,237,31"/>
<area shape="rect" id="node4" href="main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="main" alt="" coords="163,55,213,80"/>
<area shape="rect" id="node3" href="gui_8hpp.html#ace0698412b74cdbc0571809a0d903b49" title="gui" alt="" coords="285,5,324,31"/>
</map>
</div>

</div>
</div>
<a id="aceb780082d3f7392e485cac394d6c606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb780082d3f7392e485cac394d6c606">&#9670;&nbsp;</a></span>getAllColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getAllColumn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzeigen von Spalten. </p>
<p>Es werden alle Spalten der Tabelle angezeigt. <br />
</p>
<p>SQL-Befehl: "SHOW COLUMNS FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a244b10b3b373f8a174943176101a480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244b10b3b373f8a174943176101a480f">&#9670;&nbsp;</a></span>modifierColumnName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modifierColumnName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oldColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>datatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifizieren des Spaltennamens. </p>
<p>Ersetzt den Spaltennamen sowie den Datentyp falls gewünscht. <br />
 Soll der Datentyp nicht geändert werden, wird der Datentyp des Feldes nochmal angegeben.<br />
</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " CHANGE " + oldColumnName + " " + newColumnName + " " + datatype; <br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">oldColumnName</td><td>= Alter Name der Spalte </td></tr>
    <tr><td class="paramname">newColumnName</td><td>= Neuer Name der Spalte </td></tr>
    <tr><td class="paramname">datatype</td><td>= Datentyp der Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="ab254b5514a4950c7479bc4d513c438dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab254b5514a4950c7479bc4d513c438dc">&#9670;&nbsp;</a></span>modifierEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modifierEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oldEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Einträge modifizieren. </p>
<p>Die Methode "modifierEntry" senden dem Befehl einen bereits vorhandenen Eintrag einer Tabelle zu modifizieren.<br />
</p>
<p>SQL-Befehl: "UPDATE " + tableName + " SET " + columnName + " = " + "'" + newEntry + "'" + " WHERE " + columnName + "= " + "'" + oldEntry + "'";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Name der Spalte in den der Eintrag getätigt werden soll </td></tr>
    <tr><td class="paramname">oldEntry</td><td>= Alter Eintrag </td></tr>
    <tr><td class="paramname">newEntry</td><td>= enthält den Eintrag, der den alten Eintrag ersetzen soll.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_ab254b5514a4950c7479bc4d513c438dc_cgraph.png" border="0" usemap="#sqllib_8hpp_ab254b5514a4950c7479bc4d513c438dc_cgraph" alt=""/></div>
<map name="sqllib_8hpp_ab254b5514a4950c7479bc4d513c438dc_cgraph" id="sqllib_8hpp_ab254b5514a4950c7479bc4d513c438dc_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="328,5,420,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="153,31,280,56"/>
</map>
</div>

</div>
</div>
<a id="a1909c1b8666cf6e3d31a014c9a9ad2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1909c1b8666cf6e3d31a014c9a9ad2d7">&#9670;&nbsp;</a></span>ownCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ownCommand </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sqlCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>commandType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Benutzereigener SQL-Befehl. </p>
<p>Die Methode "sqlCommand" gibt einen vom Nutzer eingegebenen String(SQL Befehl) direkt weiter zum SQL Server, zu dem wird der Befehlstyp unterschieden. Es wird zwischen 3 Befehlstypen unterschieden: Query -&gt; simple Abfrage an den SQL Server feedback-&gt; zeigt den Inhalt einer Spalte an feedbackAll-&gt; zeigt die komplette Tabelle mit Spaltenbezeichnugen an</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">sqlCommand</td><td>= enthält dem vom Nutzer eingegebenen String der später als SQL Befehl fungiert </td></tr>
    <tr><td class="paramname">commandType</td><td>= enhält dem vom Nutzer gewählten Befehlstyp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<p>Boolean als return </p><dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph.png" border="0" usemap="#sqllib_8hpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph" id="sqllib_8hpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="371,56,463,82"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="178,31,305,56"/>
<area shape="rect" id="node4" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="168,80,315,106"/>
<area shape="rect" id="node5" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="161,130,323,155"/>
</map>
</div>

</div>
</div>
<a id="a0659d93a42f84756e52155eb333c4fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0659d93a42f84756e52155eb333c4fec">&#9670;&nbsp;</a></span>renameDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renameDatabase </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>databaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newDatabaseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Datenbanknamen ändern. </p>
<p>Die Methode "renameDatabase" senden dem Befehl eine Datenbank umzubennen an den SQL Server.<br />
 Bis auf die gewählte Datenbank für die <a class="el" href="connection_8cpp.html#adda241635377573037e48ec03e645c22" title="Verbindung zur Datenbank auf einem Server. ">connectionless()</a> Methode können alle Datenbanken umbenannt werden.<br />
</p>
<p>SQL-Befehl: "ALTER DATABASE " + databaseName + " MODIFY NAME = " + newDatabaseName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">databaseName</td><td>= enhält den Namen für die zu unbennene Datenbank </td></tr>
    <tr><td class="paramname">newDatabaseName</td><td>= enhält den neunen Namen für die Datenbank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a0659d93a42f84756e52155eb333c4fec_cgraph.png" border="0" usemap="#sqllib_8hpp_a0659d93a42f84756e52155eb333c4fec_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a0659d93a42f84756e52155eb333c4fec_cgraph" id="sqllib_8hpp_a0659d93a42f84756e52155eb333c4fec_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="352,5,443,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="177,31,304,56"/>
</map>
</div>

</div>
</div>
<a id="a526b049a888b2a4a1332a10540689afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526b049a888b2a4a1332a10540689afd">&#9670;&nbsp;</a></span>renameTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renameTable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newTableName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Änderung des Tabellennamens. </p>
<p>Sollte der Fall eintreten, dass Tabellennamen mit ihrem Inhalt nicht mehr übereinstimmen oder eine Umstrukturierung eintritt, kann über diese Methode der Tabellenname innerhalb einer Datenbank geändert werden.<br />
</p>
<p>SQL-Befehl: ALTER TABLE " + tablename + " RENAME TO " + newTableName+ ";" ;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Angabe des zu ersetzenden Tabellennamens </td></tr>
    <tr><td class="paramname">newTableName</td><td>= Angabe des neuen Tabellennamens</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a01bd0062142a17ad04b7101bac7b38b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bd0062142a17ad04b7101bac7b38b6">&#9670;&nbsp;</a></span>selectAverageSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectAverageSum </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Durchschnittswert. </p>
<p>Die "selectAverageSum" Methode berechnet den Durchschnittswert aller Werte, die in einer Spalte mittels einer Select-Abfrage ermitteln wurden.<br />
</p>
<p>SQL-Befehl: "SELECT AVG(" + columnName + ") FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält den Spaltennamen von der, der Durchschnitt berechnet werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph.png" border="0" usemap="#sqllib_8hpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph" id="sqllib_8hpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="382,5,473,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="186,31,334,56"/>
</map>
</div>

</div>
</div>
<a id="aaa15591ca7a3ba5d40fa77b7ae6753db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa15591ca7a3ba5d40fa77b7ae6753db">&#9670;&nbsp;</a></span>selectBetween()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectBetween </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionStringTwo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumnTwo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eingeschränkte Abfragen. </p>
<p>Die "selectBetween" Methode behinhlatet die SQL-Where Bedingungen mit einem eingeschränkten bestimmten Bereich eines Abfrageergebnisses.<br />
</p>
<p>SQL-Befehl: SELECT * " FROM " + tableName + " WHERE " + conditionColumn + " " + conditionString + " " + condition</p><ul>
<li>" AND " + conditionColumnTwo + " " + conditionString + " " + conditionTwo;</li>
</ul>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditionString</td><td>= Bedingung (Name = ...) </td></tr>
    <tr><td class="paramname">conditionStringTwo</td><td>= Bedingung (Name = ...) </td></tr>
    <tr><td class="paramname">tablenName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Spalte der ersten Bedingung </td></tr>
    <tr><td class="paramname">conditionColumn2</td><td>= Spalte der zweiten Bedingung </td></tr>
    <tr><td class="paramname">condition</td><td>= Bedingung (... = 'Hans') </td></tr>
    <tr><td class="paramname">conditionTwo</td><td>= Bedingung (... = "Hans")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph.png" border="0" usemap="#sqllib_8hpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph" id="sqllib_8hpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="372,5,463,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="161,31,324,56"/>
</map>
</div>

</div>
</div>
<a id="a0bd3f475ec96949ae94bbbbec41f7725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd3f475ec96949ae94bbbbec41f7725">&#9670;&nbsp;</a></span>selectColumnsAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectColumnsAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>aliases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias-Spaltennamen. </p>
<p>Die "selectColumnsAlias" Methode kann für übergebene Spalte(n) einen ausgwählten Alias-Spaltenname(n) hinzufügen.<br />
 Zuordnung: Spaltenname(i) = Alias-Spaltennamen(i)<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">aliases</td><td>= Enthält die Liste mit den Aliasnamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph.png" border="0" usemap="#sqllib_8hpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph" id="sqllib_8hpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="401,5,493,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="191,31,353,56"/>
</map>
</div>

</div>
</div>
<a id="a00f071477f164f70927ee9923dd77a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f071477f164f70927ee9923dd77a39">&#9670;&nbsp;</a></span>selectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCount </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzahl von ausgewählten Datensätzen. </p>
<p>Die selectCount Methode zählt(COUNT) die Anzahl von ausgewählten Datensätzen.<br />
 Es werden alle Datensätze gezählt, deren Wert nicht NULL ist. <br />
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.<br />
</p>
<p>SQL-Befehl: "SELECT COUNT(" + countColumn + ") AS " + aliasColumnName + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">countColumn</td><td>= Enthält die zu zählende Spalte </td></tr>
    <tr><td class="paramname">aliasColumn</td><td>= Enthält den gewählten Aliasnamen für die zurückgegebene Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a00f071477f164f70927ee9923dd77a39_cgraph.png" border="0" usemap="#sqllib_8hpp_a00f071477f164f70927ee9923dd77a39_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a00f071477f164f70927ee9923dd77a39_cgraph" id="sqllib_8hpp_a00f071477f164f70927ee9923dd77a39_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="355,5,447,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="145,31,307,56"/>
</map>
</div>

</div>
</div>
<a id="a8d6f770e3b1eb29fce843172c187ccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f770e3b1eb29fce843172c187ccc6">&#9670;&nbsp;</a></span>selectCountDistinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCountDistinct </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keine Redundanzen / Datensätze werden gezählt. </p>
<p>Mithilfe der "selectCountDistinct" Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt und anschließend werden diese Datensätze gezählt.<br />
</p>
<p>SQL-Befehl: "SELECT COUNT(DISTINCT " + countColumn + ") FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">countColumn</td><td>= Enthält die zu zählende Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph.png" border="0" usemap="#sqllib_8hpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph" id="sqllib_8hpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="384,5,476,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="189,31,336,56"/>
</map>
</div>

</div>
</div>
<a id="a851bc3e6b04b4dfaa359b43534a37cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851bc3e6b04b4dfaa359b43534a37cd5">&#9670;&nbsp;</a></span>selectCountGroupByOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCountGroupByOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ergebnismengen gruppieren + zählen der Datensätze + Sortierung. </p>
<p>Mithilfe der "selectCountGroupByOrderBy" Methode ist es möglich die Ergebnismenge zu gruppieren. <br />
 Das Count zählt die Anzahl der gruppierten Ergebnismengen. Es werden alle Datensätze gezählt, deren Wert nicht NULL ist. <br />
 Zudem kann der Datensatz anschließend auf- bzw. Absteigend zu sotieren werden. <br />
</p>
<p>SQL-Befehl ASC: std::string sqlCommand ="SELECT COUNT(" + countColumn +")," + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY COUNT(" + countColumn +") ASC;" SQL-Befehl DESC: std::string sqlCommand ="SELECT COUNT(" + countColumn +")," + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY COUNT(" + countColumn +") DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle , countColumn = Enthält die zu zählende Spalte </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enthält die Liste der zu gruppierenden Spaltennamen </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enthält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph.png" border="0" usemap="#sqllib_8hpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph" id="sqllib_8hpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="458,5,549,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="247,31,410,56"/>
</map>
</div>

</div>
</div>
<a id="aba13caf613af9f91f2a2f1a8f9d49967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba13caf613af9f91f2a2f1a8f9d49967">&#9670;&nbsp;</a></span>selectDistinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectDistinct </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redundanzen werden eliminiert und nur einmal angezeigt. </p>
<p>Mithilfe der "selectDistinct" Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt.<br />
</p>
<p>SQL-Befehl: "SELECT DISTINCT " + allColumns + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">column</td><td>= Enthält die Liste der angezeigten Spalten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph.png" border="0" usemap="#sqllib_8hpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph" id="sqllib_8hpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="363,5,455,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="153,31,315,56"/>
</map>
</div>

</div>
</div>
<a id="a41392b97718c999af4867dc0c62ade0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41392b97718c999af4867dc0c62ade0c">&#9670;&nbsp;</a></span>selectFullJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectFullJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FullJoin Methode. </p>
<p>Mithilfe der "selectFullJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort FULL OUTER JOIN gibt alle Datensätze zurück, wenn eine Übereinstimmung in den Datensätzen der linken (firstTable) oder der rechten (secondTable) Tabelle vorliegt.<br />
</p>
<p>SQL-Befehl select &lt;Auswahl&gt; FROM TabelleA FULL OUTER JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Name der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a41392b97718c999af4867dc0c62ade0c_cgraph.png" border="0" usemap="#sqllib_8hpp_a41392b97718c999af4867dc0c62ade0c_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a41392b97718c999af4867dc0c62ade0c_cgraph" id="sqllib_8hpp_a41392b97718c999af4867dc0c62ade0c_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="366,5,457,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="155,31,318,56"/>
</map>
</div>

</div>
</div>
<a id="a54c70afd3e6ad75085ddf6aff29abe87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c70afd3e6ad75085ddf6aff29abe87">&#9670;&nbsp;</a></span>selectGroupBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectGroupBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gruppieren von Ergebnismengen. </p>
<p>Mithilfe der "selectGroupBy" Methode ist es möglich eine Ergebnismenge zu gruppieren.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName-&gt;</td><td>Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enhält die Liste der zu gruppierenden Spaltennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph.png" border="0" usemap="#sqllib_8hpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph" id="sqllib_8hpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="372,5,464,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="162,31,324,56"/>
</map>
</div>

</div>
</div>
<a id="a5e60ce2e53b91725f89c66539e5bd73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e60ce2e53b91725f89c66539e5bd73d">&#9670;&nbsp;</a></span>selectGroupByOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectGroupByOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortcolumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ergebnismengen + sortieren. </p>
<p>Mithilfe der "selectGroupByOrderBy" Methode ist es möglich eine Ergebnismenge zu gruppieren und diese auf- bzw. Absteigend zu sortieren.<br />
</p>
<p>SQL-Befehl für ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY " + toSortcolumnName + " ASC;"<br />
 SQL-Befehl für DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY " + toSortcolumnName + " DESC;"<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enhält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enthält die Liste der zu gruppierenden Spaltennamen </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enthält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph.png" border="0" usemap="#sqllib_8hpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph" id="sqllib_8hpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="422,5,514,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="212,31,374,56"/>
</map>
</div>

</div>
</div>
<a id="ac3a0a9620e1b5ac8c90104b1daea4f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a0a9620e1b5ac8c90104b1daea4f5f">&#9670;&nbsp;</a></span>selectIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectIn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>searchInColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mehrere Abfrageergebnisse bündeln. </p>
<p>Die "selectIn" Methode kann mehrere Abfrageergebnisse in einer SQL-Anweisung zu bündeln.<br />
 Damit kann der IN Operator leicht mehrere OR Operatoren ersetzen und vereinfacht damit die Struktur von komplexen OR-Bedingungen.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + searchInColumn + " IN " + " (" + comparativValues + ");"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">searchInColumn</td><td>= Enthält den Spaltennamen in der die Werte vergleicht werden </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält eine Liste der zu vergleichenden Werten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph.png" border="0" usemap="#sqllib_8hpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph" alt=""/></div>
<map name="sqllib_8hpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph" id="sqllib_8hpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="331,5,423,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="121,31,283,56"/>
</map>
</div>

</div>
</div>
<a id="aa0d6684a1d4f8e82d699b713e38c9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d6684a1d4f8e82d699b713e38c9d44">&#9670;&nbsp;</a></span>selectInnerJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectInnerJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>InnerJoin-Befehl. </p>
<p>Mithilfe der "selectInnerJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort INNER JOIN wählt Datensätze mit übereinstimmenden Werten in beiden Tabellen aus.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA INNER JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Enthält den Tabellennamen der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph.png" border="0" usemap="#sqllib_8hpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph" id="sqllib_8hpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="375,5,466,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="164,31,327,56"/>
</map>
</div>

</div>
</div>
<a id="a85d81ccc1d4c2b8cb7edcfe0a5a585f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">&#9670;&nbsp;</a></span>selectLeftJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLeftJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LeftJoin Methode. </p>
<p>Mithilfe der "selectLeftJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort LEFT JOIN gibt alle Datensätze der linken Tabelle (firstTable) und die übereinstimmenden Datensätze der rechten Tabelle (secondTable) zurück.<br />
 Das Ergebnis ist NULL von rechts, wenn keine Übereinstimmung vorliegt.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA LEFT JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>=Enthält den Tabellennamen der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph.png" border="0" usemap="#sqllib_8hpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph" id="sqllib_8hpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="366,5,458,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="156,31,318,56"/>
</map>
</div>

</div>
</div>
<a id="a80ced4bb0e929e97740616c59374d992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ced4bb0e929e97740616c59374d992">&#9670;&nbsp;</a></span>selectLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLike </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearchColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suche nach Muster. </p>
<p>Die Methode "selectLike" ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.<br />
 Muster: Findet einen Datzensatz der z.B mit einem "a" beginnt.<br />
 Findet einen Datzensatz der z.B mit einem "a" endet.<br />
 Findet einen Datensatz der z.b ein "or" an beliebiger Positon enhält. <br />
 Findet einen Datensatz der z.B ein "r" an der zweiten Position enthält.<br />
 Findet einen Datensatz der z.B mit einem "a" beginnt und einem O anfängt. <br />
 -&gt;(Bedingung nur bei zwei Buchstaben erfüllt -&gt; Fehlermeldung bei mehr als zwei Buchstaben)<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + toSearchColumn + "  LIKE " + "'" + toSearch + "%';"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enhält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">toSearchColumn</td><td>= Enhält die zu suchende Spalte </td></tr>
    <tr><td class="paramname">pattern</td><td>= enhält das ausgewählte Muster </td></tr>
    <tr><td class="paramname">toSearch</td><td>= enhält das zu suchende Element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a80ced4bb0e929e97740616c59374d992_cgraph.png" border="0" usemap="#sqllib_8hpp_a80ced4bb0e929e97740616c59374d992_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a80ced4bb0e929e97740616c59374d992_cgraph" id="sqllib_8hpp_a80ced4bb0e929e97740616c59374d992_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="344,5,436,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="134,31,296,56"/>
</map>
</div>

</div>
</div>
<a id="a94c57cf58c1b2812e3d1ce9b3837286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c57cf58c1b2812e3d1ce9b3837286d">&#9670;&nbsp;</a></span>selectLimitWhereOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLimitWhereOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>limitNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. </p>
<p>Die Methode "selectLimitWhere" dient dazu eine vom Nutzer festgelegte Anzahl an Datensätzen abzufragen, verknüpft mit einer Bedingungs Klausel. <br />
 Zudem wird es Aufsteigend bzw. Absteigend sotiert.<br />
</p>
<p>SQL-Befehl ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + "  ORDER BY " + toSortcolumnName + " ASC " + " LIMIT " + limitNumber + ";"; SQL-Befehl DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + "  ORDER BY " + toSortColumnName + " DESC " + " LIMIT " + limitNumber + ";";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">limitNumber</td><td>= Anzahl der angezeigten Datensätze </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enhält den Bedigungswert </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>=Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph.png" border="0" usemap="#sqllib_8hpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph" id="sqllib_8hpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="437,5,528,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="227,31,389,56"/>
</map>
</div>

</div>
</div>
<a id="ae4c9217024bfe521a229e0b4162e5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c9217024bfe521a229e0b4162e5ef7">&#9670;&nbsp;</a></span>selectMinOrMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectMinOrMax </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMaxColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ermittlung des höchsten / niedrigsten Wertes. </p>
<p>Die Methode "selectMinOrMax" ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte und liefert die Spalte mit einem Aliasnamen zurück.<br />
</p>
<p>SQL-Befehl für das Minimum: "SELECT MIN(" + minOrMaxColumn +")" + " AS " + aliasColumn + " FROM " + tableName + ";" SQL-Befehl für das Maximum: "SELECT MAX(" + minOrMaxColumn +")" + " AS " + aliasColumn + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">minOrMax</td><td>= Gibt an welcher Befehl ausgeführt werden soll. </td></tr>
    <tr><td class="paramname">minOrMaxColumn</td><td>= Gibt die Spalte an, die den Min/Max Wert enthalten soll </td></tr>
    <tr><td class="paramname">asColumn</td><td>= Enhält den gewählten Aliasnamen für die Min/Max Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph.png" border="0" usemap="#sqllib_8hpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph" alt=""/></div>
<map name="sqllib_8hpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph" id="sqllib_8hpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="381,5,473,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="171,31,333,56"/>
</map>
</div>

</div>
</div>
<a id="a39f437d3c3c841e8a82b9ad1b514007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f437d3c3c841e8a82b9ad1b514007e">&#9670;&nbsp;</a></span>selectMinOrMaxWhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectMinOrMaxWhere </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMaxColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Höchster / niedrigster Wert mit Bedingung und Alias-Spalte. </p>
<p>Die Methode "selectMinOrMaxWhere" ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte verknüpft mit einer Bedigungs Klausel und liefert die Alias-Spalte zurück.<br />
</p>
<p>SQL-Befehl für das Minimum = "SELECT MIN(" + minOrMaxColumn +")" +" AS " + aliasColumn + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + ";"<br />
 SQL-Befehl für das Maximum = "SELECT MAX(" + minOrMaxColumn +")" +" AS " + aliasColumn + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Enhält den Tabellennamen </td></tr>
    <tr><td class="paramname">minOrMax</td><td>= Gibt an welcher Befehl ausgeführt werden soll. </td></tr>
    <tr><td class="paramname">minOrMaxColumn</td><td>= Gibt die Spalte an, die den Min/Max Wert enthalten soll </td></tr>
    <tr><td class="paramname">aliasColumn</td><td>= Enhält den gewählten Aliasnamen für die Min/Max Spalte </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enhält den Bedigungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph.png" border="0" usemap="#sqllib_8hpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph" id="sqllib_8hpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="420,5,512,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="210,31,372,56"/>
</map>
</div>

</div>
</div>
<a id="aab8b32ae4ac6aeddc5c05578b4c79ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8b32ae4ac6aeddc5c05578b4c79ace">&#9670;&nbsp;</a></span>selectNotLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectNotLike </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearchColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suche nach Muster. </p>
<p>Die Methode "selectNotLike" ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.<br />
 Muster: Findet einen Datzensatz der z.B nicht mit einem "a" beginnt.<br />
 Findet einen Datzensatz der z.B nicht mit einem "a" endet.<br />
 Findet einen Datensatz der z.b nicht ein "or" an beliebiger Positon enhält. <br />
 Findet einen Datensatz der z.B nicht ein "r" an der zweiten Position enthält.<br />
 Findet einen Datensatz der z.B nicht mit einem "a" beginnt und einem O anfängt.<br />
 -&gt;(Bedingung nur bei zwei Buchstaben erfüllt -&gt; Fehlermeldung bei mehr als zwei Buchstaben)<br />
</p>
<p>SQL-Befehl:</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">toSearchColumn</td><td>= Enthält die zu suchende Spalte </td></tr>
    <tr><td class="paramname">pattern</td><td>= enhält das ausgewählte Muster </td></tr>
    <tr><td class="paramname">toSearch</td><td>= enhält das zu suchende Element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph.png" border="0" usemap="#sqllib_8hpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph" id="sqllib_8hpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="365,5,457,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="155,31,317,56"/>
</map>
</div>

</div>
</div>
<a id="aedcd1503abb6715de26a92d34714dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcd1503abb6715de26a92d34714dcce">&#9670;&nbsp;</a></span>selectNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectNull </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL Werte. </p>
<p>Die selectNull Methode prüft eine Spalte auf den Wert NULL.<br />
</p>
<p>SQL-Befehl: "SELECT * " + " FROM " + tableName + " WHERE " + columnName + " IS NULL" + " OR ' '; "</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">ColumnName</td><td>= Enhält den Namen der Bedingungsspalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aedcd1503abb6715de26a92d34714dcce_cgraph.png" border="0" usemap="#sqllib_8hpp_aedcd1503abb6715de26a92d34714dcce_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aedcd1503abb6715de26a92d34714dcce_cgraph" id="sqllib_8hpp_aedcd1503abb6715de26a92d34714dcce_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="343,5,434,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="132,31,295,56"/>
</map>
</div>

</div>
</div>
<a id="aff2cca0ae3f40a8b3ec70e85702bb8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2cca0ae3f40a8b3ec70e85702bb8fc">&#9670;&nbsp;</a></span>selectRightJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectRightJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mithilfe der "selectRightJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat. <br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen. <br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort RIGHT JOIN gibt alle Datensätze der rechten Tabelle (secondTable) und die übereinstimmenden Datensätze der linken Tabelle (firstTable) zurück. <br />
 Das Ergebnis ist NULL von links, wenn keine Übereinstimmung vorliegt.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA LEFT JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle  = Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Name der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph.png" border="0" usemap="#sqllib_8hpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph" id="sqllib_8hpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="375,5,467,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="165,31,327,56"/>
</map>
</div>

</div>
</div>
<a id="a6a41ec41130fdce3f2c4dd701438f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a41ec41130fdce3f2c4dd701438f26a">&#9670;&nbsp;</a></span>selectSortTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectSortTable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tabelle wird nach Angabe sortiert. </p>
<p>Mithilfe der "selectSortTable" Methode wird eine angebene Tabelle nach einer angebenen Spalte auf- bzw. -Absteigend sortiert.<br />
 Die ganze Tabelle wird ausgebenen.<br />
</p>
<p>SQL-Befehl für ASC = "SELECT * FROM " + tableName + " ORDER BY " + toSortColumnName + " ASC;" SQL-Befehl für DESC = "SELECT * FROM " + tableName + " ORDER BY " + toSortColumnName + " DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph.png" border="0" usemap="#sqllib_8hpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph" id="sqllib_8hpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="361,5,453,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="166,31,313,56"/>
</map>
</div>

</div>
</div>
<a id="a9f37b58ba921dc5e6b5d4a5d0fefe28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f37b58ba921dc5e6b5d4a5d0fefe28e">&#9670;&nbsp;</a></span>selectSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectSum </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summieren von Werten. </p>
<p>Die "selectSum" Methode summiert die Werte einer Tabellenspalte und liefert sie zurück.<br />
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.<br />
</p>
<p>SQL-Befehl: "SELECT SUM(" + columnName + ") AS " + aliasColumnName+ " FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält den Spaltennamen von der, die Summe berechnet werden soll </td></tr>
    <tr><td class="paramname">aliasColumnName</td><td>= Enthält den Aliasnamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph.png" border="0" usemap="#sqllib_8hpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph" id="sqllib_8hpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="347,5,439,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="137,31,299,56"/>
</map>
</div>

</div>
</div>
<a id="a3ac5ebbcfb624dc5178315c85c4b15fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac5ebbcfb624dc5178315c85c4b15fa">&#9670;&nbsp;</a></span>selectTableAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectTableAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasTableName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zuweisung eines Alias. </p>
<p>Die "selectTableAlias" Methode kann der übergebnenen Tabelle einen Alias-Tabellennamen zuweisen.</p>
<p>SQL-Befehl: "SELECT " + columnAlias + " FROM " + tableName + " AS " + aliasTableName +";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen Spalten </td></tr>
    <tr><td class="paramname">aliasTabellennamen</td><td>= Enthält den Alias-Tabellennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph.png" border="0" usemap="#sqllib_8hpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph" id="sqllib_8hpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="380,5,472,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="170,31,332,56"/>
</map>
</div>

</div>
</div>
<a id="a90eb635de3f1856a45557b42f18eff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eb635de3f1856a45557b42f18eff28">&#9670;&nbsp;</a></span>selectWhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhere </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzeigen bestimmter Datensätze mit dem Zusatz der Where-Clause. </p>
<p>Mithilfe der "selectWhere" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.<br />
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "';"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a90eb635de3f1856a45557b42f18eff28_cgraph.png" border="0" usemap="#sqllib_8hpp_a90eb635de3f1856a45557b42f18eff28_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a90eb635de3f1856a45557b42f18eff28_cgraph" id="sqllib_8hpp_a90eb635de3f1856a45557b42f18eff28_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="359,5,451,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="149,31,311,56"/>
</map>
</div>

</div>
</div>
<a id="a0c986e9aa0e2d7e080ba5eb294a1182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c986e9aa0e2d7e080ba5eb294a1182e">&#9670;&nbsp;</a></span>selectWhereBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhereBool </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditions2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>operators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a519933061d4010c3a8d743b7e9fa9939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519933061d4010c3a8d743b7e9fa9939">&#9670;&nbsp;</a></span>selectWhereOneColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhereOneColumn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bestimmte Datensätze von bestimmten Spalten abfragen. </p>
<p>Mithilfe der "selectOneColumn" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.<br />
 Es wird nur die Spalte angzeigt, wo der Datensatz verglichen worden ist.</p>
<p>SQL-Befehl: "SELECT * FROM " + tableName + " WHERE " + conditionColumn + " = " + "'" + conditionValue + "';"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a519933061d4010c3a8d743b7e9fa9939_cgraph.png" border="0" usemap="#sqllib_8hpp_a519933061d4010c3a8d743b7e9fa9939_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a519933061d4010c3a8d743b7e9fa9939_cgraph" id="sqllib_8hpp_a519933061d4010c3a8d743b7e9fa9939_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="415,5,507,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="220,31,367,56"/>
</map>
</div>

</div>
</div>
<a id="a94269766ff6e39ba8a38f5623314c3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94269766ff6e39ba8a38f5623314c3cd">&#9670;&nbsp;</a></span>selectWhereOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhereOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortcolumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abfrage von Spalten mit Sortierung. </p>
<p>Mithilfe der "selectWhereOrderBy" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt. Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat. Zudem wird es Aufsteigend oder Absteigend sortiert.</p>
<p>SQL-Befehl für ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + " ORDER BY " + toSortcolumnName + " ASC;" SQL-Befehl für DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + " ORDER BY " + toSortcolumnName + " DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>=Enhält den Bedingungswert </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>=Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph.png" border="0" usemap="#sqllib_8hpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph" id="sqllib_8hpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="409,5,500,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="198,31,361,56"/>
</map>
</div>

</div>
</div>
<a id="aeb45ccd70b8692b592754a0886c2d109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb45ccd70b8692b592754a0886c2d109">&#9670;&nbsp;</a></span>setAllEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAllEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Beliebige Anzahl von Einträgen hinzufügen. </p>
<p>Die Methode "setAllEntry" senden dem Befehl eine komplette Zeile mit Einträgen einer Tabelle hinzuzufügen.<br />
 Um beliebig viele Einträge zu erstellen, muss der Anwender einen Vektoren anfertigen und diesen übergeben. <br />
 Der Vektor hat für den Insert die Form : jede gerade Index der Spaltennamen, Ungerade der Datensatz.<br />
</p>
<p>SQL-Befehl: "INSERT INTO " + tableName + "( " + columnName + " ) VALUES(" + insertData + ");";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">row</td><td>= Enhält eine Liste, die eine Zeile repräsentieren soll, gefüllt mit Einträgen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_aeb45ccd70b8692b592754a0886c2d109_cgraph.png" border="0" usemap="#sqllib_8hpp_aeb45ccd70b8692b592754a0886c2d109_cgraph" alt=""/></div>
<map name="sqllib_8hpp_aeb45ccd70b8692b592754a0886c2d109_cgraph" id="sqllib_8hpp_aeb45ccd70b8692b592754a0886c2d109_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="313,5,405,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="138,31,265,56"/>
</map>
</div>

</div>
</div>
<a id="a7c4575b6ed6eb203c2796930c41ed555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4575b6ed6eb203c2796930c41ed555">&#9670;&nbsp;</a></span>setColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setColumn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>datatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bearbeiten der Spalte in einer Tabelle. </p>
<p>Über diese Methoden kann man einzelne Spalten zu einer Tabelle hinzufügen. <br />
 Zu beachten ist, dass über diese Methode kein Schlüssel gesetzt werden kann.<br />
</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " ADD " + ColumnName + " " + datatype;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">ColumnName</td><td>= Name der Spalte die hinzugefügt werden soll </td></tr>
    <tr><td class="paramname">datatype</td><td>= Angabe des Datentyps bezogen auf die Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a4605e656585a77253f0940725b97ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4605e656585a77253f0940725b97ad04">&#9670;&nbsp;</a></span>setColumnWithPrimary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setColumnWithPrimary </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoinc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setzen des Primärschlüssels. </p>
<p>Durch diese Methode kann nachträglich der Primärschlüssel zu einer Spalte hinzugefügt werden. <br />
 Zudem kann entschieden werden, ob die Spalte mit dem Primärschlüssel direkt die AUTO_INCREMENT-Funktion nutzen soll oder über eigene Werte definiert wird.<br />
</p>
<p>SQL-Befehl für AUTO_INCREMENT: " ALTER TABLE " + tableName + " ADD " + ColumnName + " " + datatype + " PRIMARY KEY AUTO_INCREMENT";<br />
 SQL-Befehl ohne AUTO_INCREMENT: " ALTER TABLE " + tableName + " ADD " + ColumnName + " " + datatype + " PRIMARY KEY";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">ColumnName</td><td>= Name der Spalte </td></tr>
    <tr><td class="paramname">datatype</td><td>= Datentyp der Spalte </td></tr>
    <tr><td class="paramname">autoinc</td><td>= Boolean um zwischen AUTO_INCREMENT und eigener Wertzuweisung zu wechseln</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a1faab165d9a7dc43808e1a0075e007f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faab165d9a7dc43808e1a0075e007f9">&#9670;&nbsp;</a></span>setEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erstellen eines Eintrags. </p>
<p>Die Methode "setEntry" sendet den Befehl einen neuen Eintrag in die dementsprechende Tabelle einzufügen.<br />
</p>
<p>SQL-Befehl: "INSERT INTO " + tableName + " (" + columnName + ") VALUES ("+ "'" + entry + "'" + ")" ;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">ColumnName</td><td>= Name der Spalte </td></tr>
    <tr><td class="paramname">entry</td><td>= enhält den Eintrag, der hinzugefügt werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a1faab165d9a7dc43808e1a0075e007f9_cgraph.png" border="0" usemap="#sqllib_8hpp_a1faab165d9a7dc43808e1a0075e007f9_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a1faab165d9a7dc43808e1a0075e007f9_cgraph" id="sqllib_8hpp_a1faab165d9a7dc43808e1a0075e007f9_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="298,5,390,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="124,31,250,56"/>
</map>
</div>

</div>
</div>
<a id="aac2797835afcf68b73ba522e7bb91f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2797835afcf68b73ba522e7bb91f5f">&#9670;&nbsp;</a></span>setPrimaryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>primaryKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nachträgliches setzen eines Primärschlüssels. </p>
<p>Durch die Angabe der Spalte für den Primärschlüssels kann dieser gesetzt werden. <br />
 Sollte bereits ein Primärschlüssel in dieser Tabelle vorhanden sein, wird der Fehler abgefangen.<br />
</p>
<p>SQL-Befehl: "ALTER TABLE " + tableName + " ADD PRIMARY KEY (" + primaryKey + ");";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">primaryKey</td><td>= Name der Spalte für das Setzen des Primärschlüssel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a4aca01f302c4488d661196653d8f6c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aca01f302c4488d661196653d8f6c28">&#9670;&nbsp;</a></span>setSecondaryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSecondaryKey </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableNameSecondary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>foreignKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableNamePrimary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>primaryKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setzen des Sekundärschlüssels (Foreign Key) </p>
<p>tableNamePrimary und primaryKey verbinden den Primärschlüssel aus einer Tabelle mit einer vom Programmierer gewünschten Spalte und setzt den ForeignKey auf diese.<br />
 So können die Abhängigkeiten vom Primärschlüssel im Bezug auf einer anderen Tabelle gelöst werden. <br />
 Zusätzlich kann durch die Angabe des Übergabeparameters constraint eine Schlüsselgruppe definier werden.<br />
</p>
<p>SQL-Befehl "ALTER TABLE " + tableNameSecondary + " ADD CONSTRAINT "+ constraint + " FOREIGN KEY (" + foreignKey + ") REFERENCES " + tableNamePrimary + " (" + primaryKey + ");";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableNameSecondary</td><td>= Name der Tabelle für den Sekundärschlüssel </td></tr>
    <tr><td class="paramname">foreignKey</td><td>= Spaltenname für den Sekundärschlüssel </td></tr>
    <tr><td class="paramname">tableNamePrimary</td><td>= Name der Tabelle, welche den Primärschlüssel besitzt </td></tr>
    <tr><td class="paramname">primaryKey</td><td>= Spalte des Primärschlüssels </td></tr>
    <tr><td class="paramname">constraint</td><td>= Name der Schlüsselgruppe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="addc31570307c41c7327c3da4886ae7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc31570307c41c7327c3da4886ae7bf">&#9670;&nbsp;</a></span>showColumnTyp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showColumnTyp </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>datatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Datentyp der Spalte anzeigen lassen. </p>
<p>Durch die Methode werden alle Spaltennamen gelistet, welche der Bedingung des Datentyps entsprechen.<br />
</p>
<p>SQL-Befehl: "SHOW COLUMNS FROM " + tableName + " WHERE TYPE LIKE '" + datatype + "%'";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle; </td></tr>
    <tr><td class="paramname">datatype</td><td>= Datentyp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a812cc82c697df37c6a8a482f85972b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812cc82c697df37c6a8a482f85972b4b">&#9670;&nbsp;</a></span>showDatabases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showDatabases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzeigen der Datenbanken. </p>
<p>Die Methode "showDatabase" senden dem Befehl alle Datenbanken anzuzeigen an den SQL Server. <br />
</p>
<p>SQL-Befehl: SHOW DATABASES;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a812cc82c697df37c6a8a482f85972b4b_cgraph.png" border="0" usemap="#sqllib_8hpp_a812cc82c697df37c6a8a482f85972b4b_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a812cc82c697df37c6a8a482f85972b4b_cgraph" id="sqllib_8hpp_a812cc82c697df37c6a8a482f85972b4b_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="365,5,457,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="170,31,317,56"/>
</map>
</div>

</div>
</div>
<a id="a22fbeb7f18a00bafd4864de51a3bca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fbeb7f18a00bafd4864de51a3bca28">&#9670;&nbsp;</a></span>showTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showTable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ausgabe der Tabelle. </p>
<p>Diese Methode dient zur Ausgabe des kompletten Tabelleninhalts innerhalb einer Datenbank.<br />
</p>
<p>SQL-Befehl: "SELECT * FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Übergibt den Namen der auszugebenden Tabelle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Steffen Extra </dd></dl>

</div>
</div>
<a id="a1bde570da9c90a3d0f6e94bc1b06c5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde570da9c90a3d0f6e94bc1b06c5e3">&#9670;&nbsp;</a></span>unionSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unionSelect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vereinigung zweier Abfragen. </p>
<p>Die "unionSelect" Methode vereinigt die Ergebnisse zweier Abfragen.<br />
</p>
<p>SQL-Befehl: "SELECT " + columnName.at(i) + " FROM " + tableName.at(i) + " UNION ";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Enthält die Liste der Tabellennamen </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält die Liste der Spaltennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="sqllib_8hpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph.png" border="0" usemap="#sqllib_8hpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph" alt=""/></div>
<map name="sqllib_8hpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph" id="sqllib_8hpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="355,5,446,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="144,31,307,56"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="sqllib_8hpp.html">sqllib.hpp</a></li>
    <li class="footer">Erzeugt von
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
