<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SQL-Library: selectionRequest.cpp-Dateireferenz</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_home_245x108.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SQL-Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Suchen');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Suchen');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('selection_request_8cpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">selectionRequest.cpp-Dateireferenz</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;selectionRequest.hpp&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include-Abhängigkeitsdiagramm für selectionRequest.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp__incl.png" border="0" usemap="#selection_request_8cpp" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a1909c1b8666cf6e3d31a014c9a9ad2d7">ownCommand</a> (std::string sqlCommand, std::string commandType)</td></tr>
<tr class="memdesc:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Benutzereigener SQL-Befehl.  <a href="#a1909c1b8666cf6e3d31a014c9a9ad2d7">Mehr ...</a><br /></td></tr>
<tr class="separator:a1909c1b8666cf6e3d31a014c9a9ad2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ced4bb0e929e97740616c59374d992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a80ced4bb0e929e97740616c59374d992">selectLike</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string toSearchColumn, std::string pattern, std::string toSearch)</td></tr>
<tr class="memdesc:a80ced4bb0e929e97740616c59374d992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suche nach Muster.  <a href="#a80ced4bb0e929e97740616c59374d992">Mehr ...</a><br /></td></tr>
<tr class="separator:a80ced4bb0e929e97740616c59374d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aab8b32ae4ac6aeddc5c05578b4c79ace">selectNotLike</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string toSearchColumn, std::string pattern, std::string toSearch)</td></tr>
<tr class="memdesc:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suche nach Muster.  <a href="#aab8b32ae4ac6aeddc5c05578b4c79ace">Mehr ...</a><br /></td></tr>
<tr class="separator:aab8b32ae4ac6aeddc5c05578b4c79ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c9217024bfe521a229e0b4162e5ef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#ae4c9217024bfe521a229e0b4162e5ef7">selectMinOrMax</a> (std::string tableName, std::string minOrMax, std::string minOrMaxColumn, std::string aliasColumn)</td></tr>
<tr class="memdesc:ae4c9217024bfe521a229e0b4162e5ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ermittlung des höchsten / niedrigsten Wertes.  <a href="#ae4c9217024bfe521a229e0b4162e5ef7">Mehr ...</a><br /></td></tr>
<tr class="separator:ae4c9217024bfe521a229e0b4162e5ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f437d3c3c841e8a82b9ad1b514007e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a39f437d3c3c841e8a82b9ad1b514007e">selectMinOrMaxWhere</a> (std::string tableName, std::string minOrMax, std::string minOrMaxColumn, std::string aliasColumn, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a39f437d3c3c841e8a82b9ad1b514007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Höchster / niedrigster Wert mit Bedingung und Alias-Spalte.  <a href="#a39f437d3c3c841e8a82b9ad1b514007e">Mehr ...</a><br /></td></tr>
<tr class="separator:a39f437d3c3c841e8a82b9ad1b514007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a94c57cf58c1b2812e3d1ce9b3837286d">selectLimitWhereOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string limitNumber, std::string conditionColumn, std::string conditionValue, std::string toSortColumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bestimmte Anzahl von Datensätzen mit Bedingung abfragen.  <a href="#a94c57cf58c1b2812e3d1ce9b3837286d">Mehr ...</a><br /></td></tr>
<tr class="separator:a94c57cf58c1b2812e3d1ce9b3837286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519933061d4010c3a8d743b7e9fa9939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a519933061d4010c3a8d743b7e9fa9939">selectWhereOneColumn</a> (std::string tableName, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a519933061d4010c3a8d743b7e9fa9939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bestimmte Datensätze von bestimmten Spalten abfragen.  <a href="#a519933061d4010c3a8d743b7e9fa9939">Mehr ...</a><br /></td></tr>
<tr class="separator:a519933061d4010c3a8d743b7e9fa9939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb635de3f1856a45557b42f18eff28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a90eb635de3f1856a45557b42f18eff28">selectWhere</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string conditionColumn, std::string conditionValue)</td></tr>
<tr class="memdesc:a90eb635de3f1856a45557b42f18eff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzeigen bestimmter Datensätze mit dem Zusatz der Where-Clause.  <a href="#a90eb635de3f1856a45557b42f18eff28">Mehr ...</a><br /></td></tr>
<tr class="separator:a90eb635de3f1856a45557b42f18eff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad9be1bbff160a127715440afafb800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a9ad9be1bbff160a127715440afafb800">selectBool</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::vector&lt; std::string &gt;conditions, std::vector&lt; std::string &gt;conditionValue, std::vector&lt; std::string &gt; conditions2, std::vector&lt; std::string &gt;conditionValue2, std::vector&lt; std::string &gt;operators)</td></tr>
<tr class="memdesc:a9ad9be1bbff160a127715440afafb800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where-Clause mit mehreren Bedingungen.  <a href="#a9ad9be1bbff160a127715440afafb800">Mehr ...</a><br /></td></tr>
<tr class="separator:a9ad9be1bbff160a127715440afafb800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94269766ff6e39ba8a38f5623314c3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a94269766ff6e39ba8a38f5623314c3cd">selectWhereOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt; columns, std::string conditionColumn, std::string conditionValue, std::string toSortcolumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a94269766ff6e39ba8a38f5623314c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abfrage von Spalten mit Sortierung.  <a href="#a94269766ff6e39ba8a38f5623314c3cd">Mehr ...</a><br /></td></tr>
<tr class="separator:a94269766ff6e39ba8a38f5623314c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a41ec41130fdce3f2c4dd701438f26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a6a41ec41130fdce3f2c4dd701438f26a">selectSortTable</a> (std::string tableName, std::string toSortColumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a6a41ec41130fdce3f2c4dd701438f26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabelle wird nach Angabe sortiert.  <a href="#a6a41ec41130fdce3f2c4dd701438f26a">Mehr ...</a><br /></td></tr>
<tr class="separator:a6a41ec41130fdce3f2c4dd701438f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f071477f164f70927ee9923dd77a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a00f071477f164f70927ee9923dd77a39">selectCount</a> (std::string tableName, std::string countColumn, std::string aliasColumnName)</td></tr>
<tr class="memdesc:a00f071477f164f70927ee9923dd77a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anzahl von ausgewählten Datensätzen.  <a href="#a00f071477f164f70927ee9923dd77a39">Mehr ...</a><br /></td></tr>
<tr class="separator:a00f071477f164f70927ee9923dd77a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba13caf613af9f91f2a2f1a8f9d49967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aba13caf613af9f91f2a2f1a8f9d49967">selectDistinct</a> (std::string tableName, std::vector&lt; std::string &gt; columns)</td></tr>
<tr class="memdesc:aba13caf613af9f91f2a2f1a8f9d49967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redundanzen werden eliminiert und nur einmal angezeigt.  <a href="#aba13caf613af9f91f2a2f1a8f9d49967">Mehr ...</a><br /></td></tr>
<tr class="separator:aba13caf613af9f91f2a2f1a8f9d49967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f770e3b1eb29fce843172c187ccc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a8d6f770e3b1eb29fce843172c187ccc6">selectCountDistinct</a> (std::string tableName, std::string countColumn)</td></tr>
<tr class="memdesc:a8d6f770e3b1eb29fce843172c187ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keine Redundanzen / Datensätze werden gezählt.  <a href="#a8d6f770e3b1eb29fce843172c187ccc6">Mehr ...</a><br /></td></tr>
<tr class="separator:a8d6f770e3b1eb29fce843172c187ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bd0062142a17ad04b7101bac7b38b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a01bd0062142a17ad04b7101bac7b38b6">selectAverageSum</a> (std::string tableName, std::string columnName)</td></tr>
<tr class="memdesc:a01bd0062142a17ad04b7101bac7b38b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Durchschnittswert.  <a href="#a01bd0062142a17ad04b7101bac7b38b6">Mehr ...</a><br /></td></tr>
<tr class="separator:a01bd0062142a17ad04b7101bac7b38b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a9f37b58ba921dc5e6b5d4a5d0fefe28e">selectSum</a> (std::string tableName, std::string columnName, std::string aliasColumnName)</td></tr>
<tr class="memdesc:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summieren von Werten.  <a href="#a9f37b58ba921dc5e6b5d4a5d0fefe28e">Mehr ...</a><br /></td></tr>
<tr class="separator:a9f37b58ba921dc5e6b5d4a5d0fefe28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a1bde570da9c90a3d0f6e94bc1b06c5e3">unionSelect</a> (std::vector&lt; std::string &gt; tableName, std::vector&lt; std::string &gt; columnName)</td></tr>
<tr class="memdesc:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vereinigung zweier Abfragen.  <a href="#a1bde570da9c90a3d0f6e94bc1b06c5e3">Mehr ...</a><br /></td></tr>
<tr class="separator:a1bde570da9c90a3d0f6e94bc1b06c5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#ac3a0a9620e1b5ac8c90104b1daea4f5f">selectIn</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string searchInColumn, std::vector&lt; std::string &gt;conditionValue)</td></tr>
<tr class="memdesc:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mehrere Abfrageergebnisse bündeln.  <a href="#ac3a0a9620e1b5ac8c90104b1daea4f5f">Mehr ...</a><br /></td></tr>
<tr class="separator:ac3a0a9620e1b5ac8c90104b1daea4f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aaa15591ca7a3ba5d40fa77b7ae6753db">selectBetween</a> (std::string conditionString, std::string conditionStringTwo, std::string tableName, std::string conditionColumn, std::string conditionColumnTwo, std::string condition, std::string conditionTwo)</td></tr>
<tr class="memdesc:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eingeschränkte Abfragen.  <a href="#aaa15591ca7a3ba5d40fa77b7ae6753db">Mehr ...</a><br /></td></tr>
<tr class="separator:aaa15591ca7a3ba5d40fa77b7ae6753db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd3f475ec96949ae94bbbbec41f7725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a0bd3f475ec96949ae94bbbbec41f7725">selectColumnsAlias</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::vector&lt; std::string &gt;aliases)</td></tr>
<tr class="memdesc:a0bd3f475ec96949ae94bbbbec41f7725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias-Spaltennamen.  <a href="#a0bd3f475ec96949ae94bbbbec41f7725">Mehr ...</a><br /></td></tr>
<tr class="separator:a0bd3f475ec96949ae94bbbbec41f7725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a3ac5ebbcfb624dc5178315c85c4b15fa">selectTableAlias</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string aliasTableName)</td></tr>
<tr class="memdesc:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zuweisung eines Alias.  <a href="#a3ac5ebbcfb624dc5178315c85c4b15fa">Mehr ...</a><br /></td></tr>
<tr class="separator:a3ac5ebbcfb624dc5178315c85c4b15fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c70afd3e6ad75085ddf6aff29abe87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a54c70afd3e6ad75085ddf6aff29abe87">selectGroupBy</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns)</td></tr>
<tr class="memdesc:a54c70afd3e6ad75085ddf6aff29abe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gruppieren von Ergebnismengen.  <a href="#a54c70afd3e6ad75085ddf6aff29abe87">Mehr ...</a><br /></td></tr>
<tr class="separator:a54c70afd3e6ad75085ddf6aff29abe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e60ce2e53b91725f89c66539e5bd73d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a5e60ce2e53b91725f89c66539e5bd73d">selectGroupByOrderBy</a> (std::string tableName, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns, std::string toSortcolumnName, std::string sortBy)</td></tr>
<tr class="memdesc:a5e60ce2e53b91725f89c66539e5bd73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ergebnismengen + sortieren.  <a href="#a5e60ce2e53b91725f89c66539e5bd73d">Mehr ...</a><br /></td></tr>
<tr class="separator:a5e60ce2e53b91725f89c66539e5bd73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a851bc3e6b04b4dfaa359b43534a37cd5">selectCountGroupByOrderBy</a> (std::string tableName, std::string countColumn, std::vector&lt; std::string &gt;columns, std::string conditionColumn, std::string conditionValue, std::vector&lt; std::string &gt;groupByColumns, std::string sortBy)</td></tr>
<tr class="memdesc:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ergebnismengen gruppieren + zählen der Datensätze + Sortierung.  <a href="#a851bc3e6b04b4dfaa359b43534a37cd5">Mehr ...</a><br /></td></tr>
<tr class="separator:a851bc3e6b04b4dfaa359b43534a37cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcd1503abb6715de26a92d34714dcce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aedcd1503abb6715de26a92d34714dcce">selectNull</a> (std::string tableName, std::string columnName)</td></tr>
<tr class="memdesc:aedcd1503abb6715de26a92d34714dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL Werte.  <a href="#aedcd1503abb6715de26a92d34714dcce">Mehr ...</a><br /></td></tr>
<tr class="separator:aedcd1503abb6715de26a92d34714dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aa0d6684a1d4f8e82d699b713e38c9d44">selectInnerJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">InnerJoin-Befehl.  <a href="#aa0d6684a1d4f8e82d699b713e38c9d44">Mehr ...</a><br /></td></tr>
<tr class="separator:aa0d6684a1d4f8e82d699b713e38c9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">selectLeftJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LeftJoin Methode.  <a href="#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">Mehr ...</a><br /></td></tr>
<tr class="separator:a85d81ccc1d4c2b8cb7edcfe0a5a585f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2cca0ae3f40a8b3ec70e85702bb8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#aff2cca0ae3f40a8b3ec70e85702bb8fc">selectRightJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="separator:aff2cca0ae3f40a8b3ec70e85702bb8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41392b97718c999af4867dc0c62ade0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="selection_request_8cpp.html#a41392b97718c999af4867dc0c62ade0c">selectFullJoin</a> (std::string firstTableName, std::string columnIDTableOne, std::vector&lt; std::string &gt; columnsTableOne, std::string secondTableName, std::vector&lt; std::string &gt; columnsTableTwo)</td></tr>
<tr class="memdesc:a41392b97718c999af4867dc0c62ade0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">FullJoin Methode.  <a href="#a41392b97718c999af4867dc0c62ade0c">Mehr ...</a><br /></td></tr>
<tr class="separator:a41392b97718c999af4867dc0c62ade0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a id="a1909c1b8666cf6e3d31a014c9a9ad2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1909c1b8666cf6e3d31a014c9a9ad2d7">&#9670;&nbsp;</a></span>ownCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ownCommand </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sqlCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>commandType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Benutzereigener SQL-Befehl. </p>
<p>Die Methode "sqlCommand" gibt einen vom Nutzer eingegebenen String(SQL Befehl) direkt weiter zum SQL Server, zu dem wird der Befehlstyp unterschieden. Es wird zwischen 3 Befehlstypen unterschieden: Query -&gt; simple Abfrage an den SQL Server feedback-&gt; zeigt den Inhalt einer Spalte an feedbackAll-&gt; zeigt die komplette Tabelle mit Spaltenbezeichnugen an</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">sqlCommand</td><td>= enthält dem vom Nutzer eingegebenen String der später als SQL Befehl fungiert </td></tr>
    <tr><td class="paramname">commandType</td><td>= enhält dem vom Nutzer gewählten Befehlstyp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<p>Boolean als return </p><dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph.png" border="0" usemap="#selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph" id="selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="371,56,463,82"/>
<area shape="rect" id="node3" href="connection_8cpp.html#af8ead42df91543eb727f4ab7e44e49d5" title="Sendet eine Abfrage zum SQL&#45;Server. " alt="" coords="178,31,305,56"/>
<area shape="rect" id="node4" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="168,80,315,106"/>
<area shape="rect" id="node5" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="161,130,323,155"/>
</map>
</div>

</div>
</div>
<a id="a01bd0062142a17ad04b7101bac7b38b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bd0062142a17ad04b7101bac7b38b6">&#9670;&nbsp;</a></span>selectAverageSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectAverageSum </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Durchschnittswert. </p>
<p>Die "selectAverageSum" Methode berechnet den Durchschnittswert aller Werte, die in einer Spalte mittels einer Select-Abfrage ermitteln wurden.<br />
</p>
<p>SQL-Befehl: "SELECT AVG(" + columnName + ") FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält den Spaltennamen von der, der Durchschnitt berechnet werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph.png" border="0" usemap="#selection_request_8cpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph" id="selection_request_8cpp_a01bd0062142a17ad04b7101bac7b38b6_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="382,5,473,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="186,31,334,56"/>
</map>
</div>

</div>
</div>
<a id="aaa15591ca7a3ba5d40fa77b7ae6753db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa15591ca7a3ba5d40fa77b7ae6753db">&#9670;&nbsp;</a></span>selectBetween()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectBetween </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionStringTwo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumnTwo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eingeschränkte Abfragen. </p>
<p>Die "selectBetween" Methode beinhält die SQL-Where Bedingungen mit einem eingeschränkten und bestimmten Bereich eines Abfrageergebnisses.<br />
</p>
<p>SQL-Befehl: SELECT * " FROM " + tableName + " WHERE " + conditionColumn + " " + conditionString + " " + condition</p><ul>
<li>" AND " + conditionColumnTwo + " " + conditionString + " " + conditionTwo;</li>
</ul>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditionString</td><td>= Bedingung (Name = ...) </td></tr>
    <tr><td class="paramname">conditionStringTwo</td><td>= Bedingung (Name = ...) </td></tr>
    <tr><td class="paramname">tablenName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Spalte der ersten Bedingung </td></tr>
    <tr><td class="paramname">conditionColumn2</td><td>= Spalte der zweiten Bedingung </td></tr>
    <tr><td class="paramname">condition</td><td>= Bedingung (... = 'Hans') </td></tr>
    <tr><td class="paramname">conditionTwo</td><td>= Bedingung (... = "Hans")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph.png" border="0" usemap="#selection_request_8cpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph" id="selection_request_8cpp_aaa15591ca7a3ba5d40fa77b7ae6753db_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="372,5,463,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="161,31,324,56"/>
</map>
</div>

</div>
</div>
<a id="a9ad9be1bbff160a127715440afafb800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad9be1bbff160a127715440afafb800">&#9670;&nbsp;</a></span>selectBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectBool </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditions2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>operators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Where-Clause mit mehreren Bedingungen. </p>
<p>Mithilfe der "selectBool" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.<br />
 Zudem kann man ,dank der Funktion mit mehrere Bool-Bedingungen verknüpfen.<br />
 Es werden zwei Bedignungsspalten Vektoren, zwei BedingungswertVektoren sowieo ein Vektor der die Operationen enhält übergeben.<br />
 Ein Schleifendurchlauf holt sich die zwei Namen der Bedingungsspalten sowie die beiden Bedingungswerte dazu wird dann der boolische Operator hinzugefügt.<br />
 Die beiden Conditionsvektoren müssen gleich groß sein.<br />
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionOperatorString + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">conditionColumn2</td><td>= Enthält den Namen der zweiten zu vergleichnen Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue2</td><td>= Enthält den zweiten zu vergleichnenen Bedingungswert </td></tr>
    <tr><td class="paramname">operators</td><td>= Enthält die Liste der boolischen Ausdrücke</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a9ad9be1bbff160a127715440afafb800_cgraph.png" border="0" usemap="#selection_request_8cpp_a9ad9be1bbff160a127715440afafb800_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a9ad9be1bbff160a127715440afafb800_cgraph" id="selection_request_8cpp_a9ad9be1bbff160a127715440afafb800_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="346,5,438,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="136,31,298,56"/>
</map>
</div>

</div>
</div>
<a id="a0bd3f475ec96949ae94bbbbec41f7725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd3f475ec96949ae94bbbbec41f7725">&#9670;&nbsp;</a></span>selectColumnsAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectColumnsAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>aliases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias-Spaltennamen. </p>
<p>Die "selectColumnsAlias" Methode kann für übergebene Spalte(n) einen ausgwählten Alias-Spaltenname(n) hinzufügen.<br />
</p>
<p>Zuordnung: Spaltenname(i) = Alias-Spaltennamen(i)<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">aliases</td><td>= Enthält die Liste mit den Aliasnamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph.png" border="0" usemap="#selection_request_8cpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph" id="selection_request_8cpp_a0bd3f475ec96949ae94bbbbec41f7725_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="401,5,493,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="191,31,353,56"/>
</map>
</div>

</div>
</div>
<a id="a00f071477f164f70927ee9923dd77a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f071477f164f70927ee9923dd77a39">&#9670;&nbsp;</a></span>selectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCount </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzahl von ausgewählten Datensätzen. </p>
<p>Die selectCount Methode zählt(COUNT) die Anzahl von ausgewählten Datensätzen.<br />
 Es werden alle Datensätze gezählt, deren Wert nicht NULL ist. <br />
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.<br />
</p>
<p>SQL-Befehl: "SELECT COUNT(" + countColumn + ") AS " + aliasColumnName + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">countColumn</td><td>= Enthält die zu zählende Spalte </td></tr>
    <tr><td class="paramname">aliasColumn</td><td>= Enthält den gewählten Aliasnamen für die zurückgegebene Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a00f071477f164f70927ee9923dd77a39_cgraph.png" border="0" usemap="#selection_request_8cpp_a00f071477f164f70927ee9923dd77a39_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a00f071477f164f70927ee9923dd77a39_cgraph" id="selection_request_8cpp_a00f071477f164f70927ee9923dd77a39_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="355,5,447,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="145,31,307,56"/>
</map>
</div>

</div>
</div>
<a id="a8d6f770e3b1eb29fce843172c187ccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f770e3b1eb29fce843172c187ccc6">&#9670;&nbsp;</a></span>selectCountDistinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCountDistinct </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keine Redundanzen / Datensätze werden gezählt. </p>
<p>Mithilfe der "selectCountDistinct" Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt und anschließend werden diese Datensätze gezählt.<br />
</p>
<p>SQL-Befehl: "SELECT COUNT(DISTINCT " + countColumn + ") FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">countColumn</td><td>= Enthält die zu zählende Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph.png" border="0" usemap="#selection_request_8cpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph" id="selection_request_8cpp_a8d6f770e3b1eb29fce843172c187ccc6_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="384,5,476,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="189,31,336,56"/>
</map>
</div>

</div>
</div>
<a id="a851bc3e6b04b4dfaa359b43534a37cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851bc3e6b04b4dfaa359b43534a37cd5">&#9670;&nbsp;</a></span>selectCountGroupByOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectCountGroupByOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>countColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ergebnismengen gruppieren + zählen der Datensätze + Sortierung. </p>
<p>Mithilfe der "selectCountGroupByOrderBy" Methode ist es möglich die Ergebnismenge zu gruppieren. <br />
 Das Count zählt die Anzahl der gruppierten Ergebnismengen. Es werden alle Datensätze gezählt, deren Wert nicht NULL ist. <br />
 Zudem kann der Datensatz anschließend auf- bzw. Absteigend sortiert werden. <br />
</p>
<p>SQL-Befehl ASC: std::string sqlCommand ="SELECT COUNT(" + countColumn +")," + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY COUNT(" + countColumn +") ASC;" SQL-Befehl DESC: std::string sqlCommand ="SELECT COUNT(" + countColumn +")," + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY COUNT(" + countColumn +") DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle , countColumn = Enthält die zu zählende Spalte </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enthält die Liste der zu gruppierenden Spaltennamen </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enthält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph.png" border="0" usemap="#selection_request_8cpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph" id="selection_request_8cpp_a851bc3e6b04b4dfaa359b43534a37cd5_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="458,5,549,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="247,31,410,56"/>
</map>
</div>

</div>
</div>
<a id="aba13caf613af9f91f2a2f1a8f9d49967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba13caf613af9f91f2a2f1a8f9d49967">&#9670;&nbsp;</a></span>selectDistinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectDistinct </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redundanzen werden eliminiert und nur einmal angezeigt. </p>
<p>Mithilfe der "selectDistinct" Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt.<br />
</p>
<p>SQL-Befehl: "SELECT DISTINCT " + allColumns + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">column</td><td>= Enthält die Liste der angezeigten Spalten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph.png" border="0" usemap="#selection_request_8cpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph" id="selection_request_8cpp_aba13caf613af9f91f2a2f1a8f9d49967_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="363,5,455,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="153,31,315,56"/>
</map>
</div>

</div>
</div>
<a id="a41392b97718c999af4867dc0c62ade0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41392b97718c999af4867dc0c62ade0c">&#9670;&nbsp;</a></span>selectFullJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectFullJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FullJoin Methode. </p>
<p>Mithilfe der "selectFullJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort FULL OUTER JOIN gibt alle Datensätze zurück, wenn eine Übereinstimmung in den Datensätzen der linken (firstTable) oder der rechten (secondTable) Tabelle vorliegt.<br />
</p>
<p>SQL-Befehl select &lt;Auswahl&gt; FROM TabelleA FULL OUTER JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Name der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a41392b97718c999af4867dc0c62ade0c_cgraph.png" border="0" usemap="#selection_request_8cpp_a41392b97718c999af4867dc0c62ade0c_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a41392b97718c999af4867dc0c62ade0c_cgraph" id="selection_request_8cpp_a41392b97718c999af4867dc0c62ade0c_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="366,5,457,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="155,31,318,56"/>
</map>
</div>

</div>
</div>
<a id="a54c70afd3e6ad75085ddf6aff29abe87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c70afd3e6ad75085ddf6aff29abe87">&#9670;&nbsp;</a></span>selectGroupBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectGroupBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gruppieren von Ergebnismengen. </p>
<p>Mithilfe der "selectGroupBy" Methode ist es möglich eine Ergebnismenge zu gruppieren.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName-&gt;</td><td>Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enhält die Liste der zu gruppierenden Spaltennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph.png" border="0" usemap="#selection_request_8cpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph" id="selection_request_8cpp_a54c70afd3e6ad75085ddf6aff29abe87_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="372,5,464,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="162,31,324,56"/>
</map>
</div>

</div>
</div>
<a id="a5e60ce2e53b91725f89c66539e5bd73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e60ce2e53b91725f89c66539e5bd73d">&#9670;&nbsp;</a></span>selectGroupByOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectGroupByOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>groupByColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortcolumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ergebnismengen + sortieren. </p>
<p>Mithilfe der "selectGroupByOrderBy" Methode ist es möglich eine Ergebnismenge zu gruppieren und diese Auf- bzw. Absteigend zu sortieren.<br />
</p>
<p>SQL-Befehl für ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY " + toSortcolumnName + " ASC;"<br />
 SQL-Befehl für DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "' GROUP BY " + allGroupByColumns + " ORDER BY " + toSortcolumnName + " DESC;"<br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enhält die Liste der zu anzeigenen &amp; zu unbennenen Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert </td></tr>
    <tr><td class="paramname">groupByColumns</td><td>= Enthält die Liste der zu gruppierenden Spaltennamen </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enthält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph.png" border="0" usemap="#selection_request_8cpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph" id="selection_request_8cpp_a5e60ce2e53b91725f89c66539e5bd73d_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="422,5,514,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="212,31,374,56"/>
</map>
</div>

</div>
</div>
<a id="ac3a0a9620e1b5ac8c90104b1daea4f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a0a9620e1b5ac8c90104b1daea4f5f">&#9670;&nbsp;</a></span>selectIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectIn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>searchInColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mehrere Abfrageergebnisse bündeln. </p>
<p>Die "selectIn" Methode kann mehrere Abfrageergebnisse in einer SQL-Anweisung zu bündeln.<br />
 Damit kann der IN Operator leicht mehrere OR Operatoren ersetzen und vereinfacht damit die Struktur von komplexen OR-Bedingungen.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + searchInColumn + " IN " + " (" + comparativValues + ");"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">searchInColumn</td><td>= Enthält den Spaltennamen in der die Werte vergleicht werden </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält eine Liste der zu vergleichenden Werten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph.png" border="0" usemap="#selection_request_8cpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph" alt=""/></div>
<map name="selection_request_8cpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph" id="selection_request_8cpp_ac3a0a9620e1b5ac8c90104b1daea4f5f_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="331,5,423,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="121,31,283,56"/>
</map>
</div>

</div>
</div>
<a id="aa0d6684a1d4f8e82d699b713e38c9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d6684a1d4f8e82d699b713e38c9d44">&#9670;&nbsp;</a></span>selectInnerJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectInnerJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>InnerJoin-Befehl. </p>
<p>Mithilfe der "selectInnerJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten zweier Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2 um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort INNER JOIN wählt Datensätze mit übereinstimmenden Werten in beiden Tabellen aus.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA INNER JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Enthält den Tabellennamen der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph.png" border="0" usemap="#selection_request_8cpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph" id="selection_request_8cpp_aa0d6684a1d4f8e82d699b713e38c9d44_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="375,5,466,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="164,31,327,56"/>
</map>
</div>

</div>
</div>
<a id="a85d81ccc1d4c2b8cb7edcfe0a5a585f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d81ccc1d4c2b8cb7edcfe0a5a585f5">&#9670;&nbsp;</a></span>selectLeftJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLeftJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LeftJoin Methode. </p>
<p>Mithilfe der "selectLeftJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat.<br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.<br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort LEFT JOIN gibt alle Datensätze der linken Tabelle (firstTable) und die übereinstimmenden Datensätze der rechten Tabelle (secondTable) zurück.<br />
 Das Ergebnis ist NULL von rechts, wenn keine Übereinstimmung vorliegt.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA LEFT JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnIDTableOne</td><td>= Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>=Enthält den Tabellennamen der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph.png" border="0" usemap="#selection_request_8cpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph" id="selection_request_8cpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="366,5,458,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="156,31,318,56"/>
</map>
</div>

</div>
</div>
<a id="a80ced4bb0e929e97740616c59374d992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ced4bb0e929e97740616c59374d992">&#9670;&nbsp;</a></span>selectLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLike </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearchColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suche nach Muster. </p>
<p>Die Methode "selectLike" ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.<br />
 Muster: Findet einen Datzensatz der z.B mit einem "a" beginnt.<br />
 Findet einen Datzensatz der z.B mit einem "a" endet.<br />
 Findet einen Datensatz der z.b ein "or" an beliebiger Positon enhält. <br />
 Findet einen Datensatz der z.B ein "r" an der zweiten Position enthält.<br />
 Findet einen Datensatz der z.B mit einem "a" beginnt und einem O anfängt. <br />
 -&gt;(Bedingung nur bei zwei Buchstaben erfüllt -&gt; Fehlermeldung bei mehr als zwei Buchstaben)<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + toSearchColumn + "  LIKE " + "'" + toSearch + "%';"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enhält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">toSearchColumn</td><td>= Enhält die zu suchende Spalte </td></tr>
    <tr><td class="paramname">pattern</td><td>= enhält das ausgewählte Muster </td></tr>
    <tr><td class="paramname">toSearch</td><td>= enhält das zu suchende Element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a80ced4bb0e929e97740616c59374d992_cgraph.png" border="0" usemap="#selection_request_8cpp_a80ced4bb0e929e97740616c59374d992_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a80ced4bb0e929e97740616c59374d992_cgraph" id="selection_request_8cpp_a80ced4bb0e929e97740616c59374d992_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="344,5,436,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="134,31,296,56"/>
</map>
</div>

</div>
</div>
<a id="a94c57cf58c1b2812e3d1ce9b3837286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c57cf58c1b2812e3d1ce9b3837286d">&#9670;&nbsp;</a></span>selectLimitWhereOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectLimitWhereOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>limitNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. </p>
<p>Die Methode "selectLimitWhere" dient dazu eine vom Nutzer festgelegte Anzahl an Datensätzen abzufragen, verknüpft mit einer Bedingungs Klausel. <br />
 Zudem wird es Aufsteigend bzw. Absteigend sotiert.<br />
</p>
<p>SQL-Befehl ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + "  ORDER BY " + toSortcolumnName + " ASC " + " LIMIT " + limitNumber + ";"; SQL-Befehl DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + "  ORDER BY " + toSortColumnName + " DESC " + " LIMIT " + limitNumber + ";";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">limitNumber</td><td>= Anzahl der angezeigten Datensätze </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enhält den Bedigungswert </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>=Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph.png" border="0" usemap="#selection_request_8cpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph" id="selection_request_8cpp_a94c57cf58c1b2812e3d1ce9b3837286d_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="437,5,528,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="227,31,389,56"/>
</map>
</div>

</div>
</div>
<a id="ae4c9217024bfe521a229e0b4162e5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c9217024bfe521a229e0b4162e5ef7">&#9670;&nbsp;</a></span>selectMinOrMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectMinOrMax </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMaxColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ermittlung des höchsten / niedrigsten Wertes. </p>
<p>Die Methode "selectMinOrMax" ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte und liefert die Spalte mit einem Aliasnamen zurück.<br />
</p>
<p>SQL-Befehl für das Minimum: "SELECT MIN(" + minOrMaxColumn +")" + " AS " + aliasColumn + " FROM " + tableName + ";" SQL-Befehl für das Maximum: "SELECT MAX(" + minOrMaxColumn +")" + " AS " + aliasColumn + " FROM " + tableName + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">minOrMax</td><td>= Gibt an welcher Befehl ausgeführt werden soll. </td></tr>
    <tr><td class="paramname">minOrMaxColumn</td><td>= Gibt die Spalte an, die den Min/Max Wert enthalten soll </td></tr>
    <tr><td class="paramname">asColumn</td><td>= Enhält den gewählten Aliasnamen für die Min/Max Spalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph.png" border="0" usemap="#selection_request_8cpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph" alt=""/></div>
<map name="selection_request_8cpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph" id="selection_request_8cpp_ae4c9217024bfe521a229e0b4162e5ef7_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="381,5,473,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="171,31,333,56"/>
</map>
</div>

</div>
</div>
<a id="a39f437d3c3c841e8a82b9ad1b514007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f437d3c3c841e8a82b9ad1b514007e">&#9670;&nbsp;</a></span>selectMinOrMaxWhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectMinOrMaxWhere </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>minOrMaxColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Höchster / niedrigster Wert mit Bedingung und Alias-Spalte. </p>
<p>Die Methode "selectMinOrMaxWhere" ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte verknüpft mit einer Bedigungs Klausel und liefert die Alias-Spalte zurück.<br />
</p>
<p>SQL-Befehl für das Minimum = "SELECT MIN(" + minOrMaxColumn +")" +" AS " + aliasColumn + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + ";"<br />
 SQL-Befehl für das Maximum = "SELECT MAX(" + minOrMaxColumn +")" +" AS " + aliasColumn + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + ";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Enhält den Tabellennamen </td></tr>
    <tr><td class="paramname">minOrMax</td><td>= Gibt an welcher Befehl ausgeführt werden soll. </td></tr>
    <tr><td class="paramname">minOrMaxColumn</td><td>= Gibt die Spalte an, die den Min/Max Wert enthalten soll </td></tr>
    <tr><td class="paramname">aliasColumn</td><td>= Enhält den gewählten Aliasnamen für die Min/Max Spalte </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enhält den Bedigungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph.png" border="0" usemap="#selection_request_8cpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph" id="selection_request_8cpp_a39f437d3c3c841e8a82b9ad1b514007e_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="420,5,512,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="210,31,372,56"/>
</map>
</div>

</div>
</div>
<a id="aab8b32ae4ac6aeddc5c05578b4c79ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8b32ae4ac6aeddc5c05578b4c79ace">&#9670;&nbsp;</a></span>selectNotLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectNotLike </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearchColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSearch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suche nach Muster. </p>
<p>Die Methode "selectNotLike" ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.<br />
 Muster: Findet einen Datzensatz der z.B nicht mit einem "a" beginnt.<br />
 Findet einen Datzensatz der z.B nicht mit einem "a" endet.<br />
 Findet einen Datensatz der z.b nicht ein "or" an beliebiger Positon enhält. <br />
 Findet einen Datensatz der z.B nicht ein "r" an der zweiten Position enthält.<br />
 Findet einen Datensatz der z.B nicht mit einem "a" beginnt und einem O anfängt.<br />
 -&gt;(Bedingung nur bei zwei Buchstaben erfüllt -&gt; Fehlermeldung bei mehr als zwei Buchstaben)<br />
</p>
<p>SQL-Befehl:</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">toSearchColumn</td><td>= Enthält die zu suchende Spalte </td></tr>
    <tr><td class="paramname">pattern</td><td>= enhält das ausgewählte Muster </td></tr>
    <tr><td class="paramname">toSearch</td><td>= enhält das zu suchende Element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Boolean als Rückgabewert</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph.png" border="0" usemap="#selection_request_8cpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph" id="selection_request_8cpp_aab8b32ae4ac6aeddc5c05578b4c79ace_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="365,5,457,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="155,31,317,56"/>
</map>
</div>

</div>
</div>
<a id="aedcd1503abb6715de26a92d34714dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcd1503abb6715de26a92d34714dcce">&#9670;&nbsp;</a></span>selectNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectNull </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL Werte. </p>
<p>Die selectNull Methode prüft eine Spalte auf den Wert NULL.<br />
</p>
<p>SQL-Befehl: "SELECT * " + " FROM " + tableName + " WHERE " + columnName + " IS NULL" + " OR ' '; "</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">ColumnName</td><td>= Enhält den Namen der Bedingungsspalte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aedcd1503abb6715de26a92d34714dcce_cgraph.png" border="0" usemap="#selection_request_8cpp_aedcd1503abb6715de26a92d34714dcce_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aedcd1503abb6715de26a92d34714dcce_cgraph" id="selection_request_8cpp_aedcd1503abb6715de26a92d34714dcce_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="343,5,434,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="132,31,295,56"/>
</map>
</div>

</div>
</div>
<a id="aff2cca0ae3f40a8b3ec70e85702bb8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2cca0ae3f40a8b3ec70e85702bb8fc">&#9670;&nbsp;</a></span>selectRightJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectRightJoin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnIDTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secondTableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnsTableTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mithilfe der "selectRightJoin" Methode wird eine neue Ergebnistabelle erstellt.<br />
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (firstTable und secondTable) basierend auf dem Join-Prädikat. <br />
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen. <br />
 Wenn das Join-Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.<br />
 Das Schlüsselwort RIGHT JOIN gibt alle Datensätze der rechten Tabelle (secondTable) und die übereinstimmenden Datensätze der linken Tabelle (firstTable) zurück. <br />
 Das Ergebnis ist NULL von links, wenn keine Übereinstimmung vorliegt.<br />
</p>
<p>SQL-Befehl: select &lt;Auswahl&gt; FROM TabelleA LEFT JOIN TabelleB B ON A.ID = B.ID</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstTableName</td><td>= Name der ersten Tabelle  = Enthält die zu vergleichene Spalte der ersten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableOne</td><td>= Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen </td></tr>
    <tr><td class="paramname">secondTableName</td><td>= Name der zweiten Tabelle </td></tr>
    <tr><td class="paramname">columnsTableTwo</td><td>= Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph.png" border="0" usemap="#selection_request_8cpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph" alt=""/></div>
<map name="selection_request_8cpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph" id="selection_request_8cpp_aff2cca0ae3f40a8b3ec70e85702bb8fc_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="375,5,467,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="165,31,327,56"/>
</map>
</div>

</div>
</div>
<a id="a6a41ec41130fdce3f2c4dd701438f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a41ec41130fdce3f2c4dd701438f26a">&#9670;&nbsp;</a></span>selectSortTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectSortTable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tabelle wird nach Angabe sortiert. </p>
<p>Mithilfe der "selectSortTable" Methode wird eine angebene Tabelle nach einer angebenen Spalte auf- bzw. -Absteigend sortiert.<br />
 Die ganze Tabelle wird ausgebenen.<br />
</p>
<p>SQL-Befehl für ASC = "SELECT * FROM " + tableName + " ORDER BY " + toSortColumnName + " ASC;" SQL-Befehl für DESC = "SELECT * FROM " + tableName + " ORDER BY " + toSortColumnName + " DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>= Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph.png" border="0" usemap="#selection_request_8cpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph" id="selection_request_8cpp_a6a41ec41130fdce3f2c4dd701438f26a_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="361,5,453,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="166,31,313,56"/>
</map>
</div>

</div>
</div>
<a id="a9f37b58ba921dc5e6b5d4a5d0fefe28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f37b58ba921dc5e6b5d4a5d0fefe28e">&#9670;&nbsp;</a></span>selectSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectSum </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasColumnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summieren von Werten. </p>
<p>Die "selectSum" Methode summiert die Werte einer Tabellenspalte und liefert sie zurück.<br />
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.<br />
</p>
<p>SQL-Befehl: "SELECT SUM(" + columnName + ") AS " + aliasColumnName+ " FROM " + tableName;</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält den Spaltennamen von der, die Summe berechnet werden soll </td></tr>
    <tr><td class="paramname">aliasColumnName</td><td>= Enthält den Aliasnamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph.png" border="0" usemap="#selection_request_8cpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph" id="selection_request_8cpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="347,5,439,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="137,31,299,56"/>
</map>
</div>

</div>
</div>
<a id="a3ac5ebbcfb624dc5178315c85c4b15fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac5ebbcfb624dc5178315c85c4b15fa">&#9670;&nbsp;</a></span>selectTableAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectTableAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aliasTableName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zuweisung eines Alias. </p>
<p>Die "selectTableAlias" Methode kann der übergebenen Tabelle einen Alias-Tabellennamen zuweisen.</p>
<p>SQL-Befehl: "SELECT " + columnAlias + " FROM " + tableName + " AS " + aliasTableName +";"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der zu anzeigenen Spalten </td></tr>
    <tr><td class="paramname">aliasTabellennamen</td><td>= Enthält den Alias-Tabellennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph.png" border="0" usemap="#selection_request_8cpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph" id="selection_request_8cpp_a3ac5ebbcfb624dc5178315c85c4b15fa_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="380,5,472,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="170,31,332,56"/>
</map>
</div>

</div>
</div>
<a id="a90eb635de3f1856a45557b42f18eff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eb635de3f1856a45557b42f18eff28">&#9670;&nbsp;</a></span>selectWhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhere </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anzeigen bestimmter Datensätze mit dem Zusatz der Where-Clause. </p>
<p>Mithilfe der "selectWhere" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.<br />
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.<br />
</p>
<p>SQL-Befehl: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "';"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a90eb635de3f1856a45557b42f18eff28_cgraph.png" border="0" usemap="#selection_request_8cpp_a90eb635de3f1856a45557b42f18eff28_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a90eb635de3f1856a45557b42f18eff28_cgraph" id="selection_request_8cpp_a90eb635de3f1856a45557b42f18eff28_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="359,5,451,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="149,31,311,56"/>
</map>
</div>

</div>
</div>
<a id="a519933061d4010c3a8d743b7e9fa9939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519933061d4010c3a8d743b7e9fa9939">&#9670;&nbsp;</a></span>selectWhereOneColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhereOneColumn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bestimmte Datensätze von bestimmten Spalten abfragen. </p>
<p>Mithilfe der "selectOneColumn" Methode werden SQL-Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.<br />
 Es wird nur die Spalte angzeigt, wo der Datensatz verglichen worden ist.<br />
</p>
<p>SQL-Befehl: "SELECT * FROM " + tableName + " WHERE " + conditionColumn + " = " + "'" + conditionValue + "';" <br />
</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enthält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>= Enthält den Bedingungswert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void  Die Funktion gibt ein void zurück -&gt; to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a519933061d4010c3a8d743b7e9fa9939_cgraph.png" border="0" usemap="#selection_request_8cpp_a519933061d4010c3a8d743b7e9fa9939_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a519933061d4010c3a8d743b7e9fa9939_cgraph" id="selection_request_8cpp_a519933061d4010c3a8d743b7e9fa9939_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="415,5,507,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#ab12a404eefae07281e8d1273ca3fc447" title="Rückgabe einzelner Ergebnisse. " alt="" coords="220,31,367,56"/>
</map>
</div>

</div>
</div>
<a id="a94269766ff6e39ba8a38f5623314c3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94269766ff6e39ba8a38f5623314c3cd">&#9670;&nbsp;</a></span>selectWhereOrderBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectWhereOrderBy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>conditionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toSortcolumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sortBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abfrage von Spalten mit Sortierung. </p>
<p>Mithilfe der "selectWhereOrderBy" Methode werden die SQL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt. Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat. Zudem wird es Aufsteigend oder Absteigend sortiert.</p>
<p>SQL-Befehl für ASC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + " ORDER BY " + toSortcolumnName + " ASC;" SQL-Befehl für DESC: "SELECT " + allColumns + " FROM " + tableName + " WHERE " + conditionColumn + " = '" + conditionValue + "'" + " ORDER BY " + toSortcolumnName + " DESC;"</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Name der Tabelle </td></tr>
    <tr><td class="paramname">columns</td><td>= Enthält die Liste der angezeigten Spalten </td></tr>
    <tr><td class="paramname">conditionColumn</td><td>= Enhält den Namen der Bedingungsspalte </td></tr>
    <tr><td class="paramname">conditionValue</td><td>=Enhält den Bedingungswert </td></tr>
    <tr><td class="paramname">toSortColumnName</td><td>=Enhält die Spalte zu der sotiert werden soll </td></tr>
    <tr><td class="paramname">SortBy</td><td>= Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph.png" border="0" usemap="#selection_request_8cpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph" id="selection_request_8cpp_a94269766ff6e39ba8a38f5623314c3cd_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="409,5,500,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="198,31,361,56"/>
</map>
</div>

</div>
</div>
<a id="a1bde570da9c90a3d0f6e94bc1b06c5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde570da9c90a3d0f6e94bc1b06c5e3">&#9670;&nbsp;</a></span>unionSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unionSelect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>columnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vereinigung zweier Abfragen. </p>
<p>Die "unionSelect" Methode vereinigt die Ergebnisse zweier Abfragen.<br />
</p>
<p>SQL-Befehl: "SELECT " + columnName.at(i) + " FROM " + tableName.at(i) + " UNION ";</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>= Enthält die Liste der Tabellennamen </td></tr>
    <tr><td class="paramname">columnName</td><td>= Enthält die Liste der Spaltennamen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>void</dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Martin Meyer </dd>
<dd>
Steffen Extra </dd></dl>
<div class="dynheader">
Hier ist ein Graph, der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="selection_request_8cpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph.png" border="0" usemap="#selection_request_8cpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph" alt=""/></div>
<map name="selection_request_8cpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph" id="selection_request_8cpp_a1bde570da9c90a3d0f6e94bc1b06c5e3_cgraph">
<area shape="rect" id="node2" href="connection_8cpp.html#a33fd832a9e1a27bddb7d9837a2dcf2f1" title="Fehlermethode. " alt="" coords="355,5,446,31"/>
<area shape="rect" id="node3" href="connection_8cpp.html#a05a069b8d1bef185dd0ff85424e2e13c" title="Rückgabe aller Datensätze. " alt="" coords="144,31,307,56"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="selection_request_8cpp.html">selectionRequest.cpp</a></li>
    <li class="footer">Erzeugt von
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
