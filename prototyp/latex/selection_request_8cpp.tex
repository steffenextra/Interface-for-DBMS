\section{selection\+Request.\+cpp-\/\+Dateireferenz}
\label{selection_request_8cpp}\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}}
{\ttfamily \#include \char`\"{}selection\+Request.\+hpp\char`\"{}}\newline
\subsection*{Funktionen}
\begin{DoxyCompactItemize}
\item 
void \textbf{ sql\+Command} (std\+::string sql\+Command, std\+::string command\+Type)
\begin{DoxyCompactList}\small\item\em Benutzereigener S\+Q\+L-\/\+Befehl. \end{DoxyCompactList}\item 
void \textbf{ select\+Like} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string to\+Search\+Column, std\+::string pattern, std\+::string to\+Search)
\begin{DoxyCompactList}\small\item\em Suche nach Muster. \end{DoxyCompactList}\item 
void \textbf{ select\+Not\+Like} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string to\+Search\+Column, std\+::string pattern, std\+::string to\+Search)
\begin{DoxyCompactList}\small\item\em Suche nach Muster. \end{DoxyCompactList}\item 
void \textbf{ select\+Min\+Or\+Max} (std\+::string table\+Name, std\+::string min\+Or\+Max, std\+::string min\+Or\+Max\+Column, std\+::string alias\+Column)
\begin{DoxyCompactList}\small\item\em Ermittlung des höchsten / niedrigsten Wertes. \end{DoxyCompactList}\item 
void \textbf{ select\+Min\+Or\+Max\+Where} (std\+::string table\+Name, std\+::string min\+Or\+Max, std\+::string min\+Or\+Max\+Column, std\+::string alias\+Column, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Höchster / niedrigster Wert mit Bedingung und Alias-\/\+Spalte. \end{DoxyCompactList}\item 
void \textbf{ select\+Limit\+Where\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string limit\+Number, std\+::string condition\+Column, std\+::string condition\+Value, std\+::string to\+Sort\+Column\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. \end{DoxyCompactList}\item 
void \textbf{ select\+Where\+One\+Column} (std\+::string table\+Name, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Bestimmte Datensätze von bestimmten Spalten abfragen. \end{DoxyCompactList}\item 
void \textbf{ select\+Where} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Anzeigen bestimmter Datensätze mit dem Zusatz der Where-\/\+Clause. \end{DoxyCompactList}\item 
void \textbf{ select\+Bool} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::vector$<$ std\+::string $>$conditions, std\+::vector$<$ std\+::string $>$condition\+Value, std\+::vector$<$ std\+::string $>$ conditions2, std\+::vector$<$ std\+::string $>$condition\+Value2, std\+::vector$<$ std\+::string $>$operators)
\begin{DoxyCompactList}\small\item\em Where-\/\+Clause mit mehreren Bedingungen. \end{DoxyCompactList}\item 
void \textbf{ select\+Where\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::string to\+Sortcolumn\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Abfrage von Spalten mit Sortierung. \end{DoxyCompactList}\item 
void \textbf{ select\+Sort\+Table} (std\+::string table\+Name, std\+::string to\+Sort\+Column\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Tabelle wird nach Angabe sortiert. \end{DoxyCompactList}\item 
void \textbf{ select\+Count} (std\+::string table\+Name, std\+::string count\+Column, std\+::string alias\+Column\+Name)
\begin{DoxyCompactList}\small\item\em Anzahl von ausgewählten Datensätzen. \end{DoxyCompactList}\item 
void \textbf{ select\+Distinct} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns)
\begin{DoxyCompactList}\small\item\em Redundanzen werden eliminiert und nur einmal angezeigt. \end{DoxyCompactList}\item 
void \textbf{ select\+Count\+Distinct} (std\+::string table\+Name, std\+::string count\+Column)
\begin{DoxyCompactList}\small\item\em Keine Redundanzen / Datensätze werden gezählt. \end{DoxyCompactList}\item 
void \textbf{ select\+Average\+Sum} (std\+::string table\+Name, std\+::string column\+Name)
\item 
void \textbf{ select\+Sum} (std\+::string table\+Name, std\+::string column\+Name, std\+::string alias\+Column\+Name)
\item 
void \textbf{ union\+Select} (std\+::vector$<$ std\+::string $>$ table\+Name, std\+::vector$<$ std\+::string $>$ column\+Name)
\item 
void \textbf{ select\+In} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string search\+In\+Column, std\+::vector$<$ std\+::string $>$condition\+Value)
\item 
void \textbf{ select\+Between} (std\+::string condition\+String, std\+::string condition\+String\+Two, std\+::string table\+Name, std\+::string condition\+Column, std\+::string condition\+Column\+Two, std\+::string condition, std\+::string condition\+Two)
\item 
void \textbf{ select\+Columns\+Alias} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::vector$<$ std\+::string $>$aliases)
\item 
void \textbf{ select\+Table\+Alias} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string alias\+Table\+Name)
\item 
void \textbf{ select\+Group\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns)
\item 
void \textbf{ select\+Group\+By\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns, std\+::string to\+Sortcolumn\+Name, std\+::string sort\+By)
\item 
void \textbf{ select\+Count\+Group\+By\+Order\+By} (std\+::string table\+Name, std\+::string count\+Column, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns, std\+::string sort\+By)
\item 
void \textbf{ select\+Null} (std\+::string table\+Name, std\+::string column\+Name)
\item 
void \textbf{ select\+Inner\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\item 
void \textbf{ select\+Left\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\item 
void \textbf{ select\+Right\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\item 
void \textbf{ select\+Full\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\end{DoxyCompactItemize}


\subsection{Dokumentation der Funktionen}
\mbox{\label{selection_request_8cpp_a01bd0062142a17ad04b7101bac7b38b6}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Average\+Sum@{select\+Average\+Sum}}
\index{select\+Average\+Sum@{select\+Average\+Sum}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Average\+Sum()}
{\footnotesize\ttfamily void select\+Average\+Sum (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_aaa15591ca7a3ba5d40fa77b7ae6753db}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Between@{select\+Between}}
\index{select\+Between@{select\+Between}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Between()}
{\footnotesize\ttfamily void select\+Between (\begin{DoxyParamCaption}\item[{std\+::string}]{condition\+String,  }\item[{std\+::string}]{condition\+String\+Two,  }\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Column\+Two,  }\item[{std\+::string}]{condition,  }\item[{std\+::string}]{condition\+Two }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a9ad9be1bbff160a127715440afafb800}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Bool@{select\+Bool}}
\index{select\+Bool@{select\+Bool}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Bool()}
{\footnotesize\ttfamily void select\+Bool (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::vector$<$ std\+::string $>$}]{conditions,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{conditions2,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value2,  }\item[{std\+::vector$<$ std\+::string $>$}]{operators }\end{DoxyParamCaption})}



Where-\/\+Clause mit mehreren Bedingungen. 

Mithilfe der \char`\"{}select\+Bool\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Zudem kann man ,dank der Funktion mit mehrere Bool-\/\+Bedingungen verknüpfen.~\newline
 Es werden zwei Bedignungsspalten Vektoren, zwei Bedingungswert\+Vektoren sowieo ein Vektor der die Operationen enhält übergeben.~\newline
 Ein Schleifendurchlauf holt sich die zwei Namen der Bedingungsspalten sowie die beiden Bedingungswerte dazu wird dann der boolische Operator hinzugefügt.~\newline
 Die beiden Conditionsvektoren müssen gleich groß sein.~\newline
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Operator\+String + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert \\
\hline
{\em condition\+Column2} & = Enthält den Namen der zweiten zu vergleichnen Bedingungsspalte \\
\hline
{\em condition\+Value2} & = Enthält den zweiten zu vergleichnenen Bedingungswert \\
\hline
{\em operators} & = Enthält die Liste der boolischen Ausdrücke\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Die Funktion gibt ein void zurück -\/$>$ to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a0bd3f475ec96949ae94bbbbec41f7725}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Columns\+Alias@{select\+Columns\+Alias}}
\index{select\+Columns\+Alias@{select\+Columns\+Alias}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Columns\+Alias()}
{\footnotesize\ttfamily void select\+Columns\+Alias (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::vector$<$ std\+::string $>$}]{aliases }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a00f071477f164f70927ee9923dd77a39}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count@{select\+Count}}
\index{select\+Count@{select\+Count}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count()}
{\footnotesize\ttfamily void select\+Count (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column,  }\item[{std\+::string}]{alias\+Column\+Name }\end{DoxyParamCaption})}



Anzahl von ausgewählten Datensätzen. 

Die select\+Count Methode zählt(\+C\+O\+U\+N\+T) die Anzahl von ausgewählten Datensätzen.~\newline
 Es werden alle Datensätze gezählt, deren Wert nicht N\+U\+LL ist. ~\newline
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\char`\"{} + count\+Column + \char`\"{}) A\+S \char`\"{} + alias\+Column\+Name + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em count\+Column} & = Enthält die zu zählende Spalte \\
\hline
{\em alias\+Column} & = Enthält den gewählten Aliasnamen für die zurückgegebene Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a8d6f770e3b1eb29fce843172c187ccc6}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count\+Distinct@{select\+Count\+Distinct}}
\index{select\+Count\+Distinct@{select\+Count\+Distinct}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count\+Distinct()}
{\footnotesize\ttfamily void select\+Count\+Distinct (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column }\end{DoxyParamCaption})}



Keine Redundanzen / Datensätze werden gezählt. 

Mithilfe der \char`\"{}select\+Count\+Distinct\char`\"{} Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt und anschließend werden diese Datensätze gezählt.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\+D\+I\+S\+T\+I\+N\+C\+T \char`\"{} + count\+Column + \char`\"{}) F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em count\+Column} & = Enthält die zu zählende Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a851bc3e6b04b4dfaa359b43534a37cd5}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count\+Group\+By\+Order\+By@{select\+Count\+Group\+By\+Order\+By}}
\index{select\+Count\+Group\+By\+Order\+By@{select\+Count\+Group\+By\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count\+Group\+By\+Order\+By()}
{\footnotesize\ttfamily void select\+Count\+Group\+By\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_aba13caf613af9f91f2a2f1a8f9d49967}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Distinct@{select\+Distinct}}
\index{select\+Distinct@{select\+Distinct}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Distinct()}
{\footnotesize\ttfamily void select\+Distinct (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns }\end{DoxyParamCaption})}



Redundanzen werden eliminiert und nur einmal angezeigt. 

Mithilfe der \char`\"{}select\+Distinct\char`\"{} Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T D\+I\+S\+T\+I\+N\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em column} & = Enthält die Liste der angezeigten Spalten\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a41392b97718c999af4867dc0c62ade0c}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Full\+Join@{select\+Full\+Join}}
\index{select\+Full\+Join@{select\+Full\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Full\+Join()}
{\footnotesize\ttfamily void select\+Full\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a54c70afd3e6ad75085ddf6aff29abe87}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Group\+By@{select\+Group\+By}}
\index{select\+Group\+By@{select\+Group\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Group\+By()}
{\footnotesize\ttfamily void select\+Group\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a5e60ce2e53b91725f89c66539e5bd73d}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Group\+By\+Order\+By@{select\+Group\+By\+Order\+By}}
\index{select\+Group\+By\+Order\+By@{select\+Group\+By\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Group\+By\+Order\+By()}
{\footnotesize\ttfamily void select\+Group\+By\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns,  }\item[{std\+::string}]{to\+Sortcolumn\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_ac3a0a9620e1b5ac8c90104b1daea4f5f}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+In@{select\+In}}
\index{select\+In@{select\+In}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+In()}
{\footnotesize\ttfamily void select\+In (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{search\+In\+Column,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_aa0d6684a1d4f8e82d699b713e38c9d44}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Inner\+Join@{select\+Inner\+Join}}
\index{select\+Inner\+Join@{select\+Inner\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Inner\+Join()}
{\footnotesize\ttfamily void select\+Inner\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a85d81ccc1d4c2b8cb7edcfe0a5a585f5}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Left\+Join@{select\+Left\+Join}}
\index{select\+Left\+Join@{select\+Left\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Left\+Join()}
{\footnotesize\ttfamily void select\+Left\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a80ced4bb0e929e97740616c59374d992}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Like@{select\+Like}}
\index{select\+Like@{select\+Like}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Like()}
{\footnotesize\ttfamily void select\+Like (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{to\+Search\+Column,  }\item[{std\+::string}]{pattern,  }\item[{std\+::string}]{to\+Search }\end{DoxyParamCaption})}



Suche nach Muster. 

Die Methode \char`\"{}select\+Like\char`\"{} ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.~\newline
 Muster\+: Findet einen Datzensatz der z.\+B mit einem \char`\"{}a\char`\"{} beginnt.~\newline
 Findet einen Datzensatz der z.\+B mit einem \char`\"{}a\char`\"{} endet.~\newline
 Findet einen Datensatz der z.\+b ein \char`\"{}or\char`\"{} an beliebiger Positon enhält. ~\newline
 Findet einen Datensatz der z.\+B ein \char`\"{}r\char`\"{} an der zweiten Position enthält.~\newline
 Findet einen Datensatz der z.\+B mit einem \char`\"{}a\char`\"{} beginnt und einem O anfängt. ~\newline
 -\/$>$(Bedingung nur bei zwei Buchstaben erfüllt -\/$>$ Fehlermeldung bei mehr als zwei Buchstaben)~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + to\+Search\+Column + \char`\"{}  L\+I\+K\+E \char`\"{} + \char`\"{}\textquotesingle{}\char`\"{} + to\+Search + \char`\"{}\%\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enhält die Liste der angezeigten Spalten \\
\hline
{\em to\+Search\+Column} & = Enhält die zu suchende Spalte \\
\hline
{\em pattern} & = enhält das ausgewählte Muster \\
\hline
{\em to\+Search} & = enhält das zu suchende Element\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Boolean als Rückgabewert
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a94c57cf58c1b2812e3d1ce9b3837286d}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Limit\+Where\+Order\+By@{select\+Limit\+Where\+Order\+By}}
\index{select\+Limit\+Where\+Order\+By@{select\+Limit\+Where\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Limit\+Where\+Order\+By()}
{\footnotesize\ttfamily void select\+Limit\+Where\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{limit\+Number,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::string}]{to\+Sort\+Column\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. 

Die Methode \char`\"{}select\+Limit\+Where\char`\"{} dient dazu eine vom Nutzer festgelegte Anzahl an Datensätzen abzufragen, verknüpft mit einer Bedingungs Klausel. ~\newline
 Zudem wird es Aufsteigend bzw. Absteigend sotiert.~\newline


S\+Q\+L-\/\+Befehl A\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{}  O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} A\+S\+C \char`\"{} + \char`\"{} L\+I\+M\+I\+T \char`\"{} + limit\+Number + \char`\"{};\char`\"{}; S\+Q\+L-\/\+Befehl D\+E\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{}  O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} D\+E\+S\+C \char`\"{} + \char`\"{} L\+I\+M\+I\+T \char`\"{} + limit\+Number + \char`\"{};\char`\"{};


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em limit\+Number} & = Anzahl der angezeigten Datensätze \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enhält den Bedigungswert \\
\hline
{\em to\+Sort\+Column\+Name} & = Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & =Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Die Funktion gibt ein void zurück -\/$>$ to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_ae4c9217024bfe521a229e0b4162e5ef7}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Min\+Or\+Max@{select\+Min\+Or\+Max}}
\index{select\+Min\+Or\+Max@{select\+Min\+Or\+Max}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Min\+Or\+Max()}
{\footnotesize\ttfamily void select\+Min\+Or\+Max (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{min\+Or\+Max,  }\item[{std\+::string}]{min\+Or\+Max\+Column,  }\item[{std\+::string}]{alias\+Column }\end{DoxyParamCaption})}



Ermittlung des höchsten / niedrigsten Wertes. 

Die Methode \char`\"{}select\+Min\+Or\+Max\char`\"{} ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte und liefert die Spalte mit einem Aliasnamen zurück.~\newline


S\+Q\+L-\/\+Befehl für das Minimum\+: \char`\"{}\+S\+E\+L\+E\+C\+T M\+I\+N(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} + \char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{} S\+Q\+L-\/\+Befehl für das Maximum\+: \char`\"{}\+S\+E\+L\+E\+C\+T M\+A\+X(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} + \char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em min\+Or\+Max} & = Gibt an welcher Befehl ausgeführt werden soll. \\
\hline
{\em min\+Or\+Max\+Column} & = Gibt die Spalte an, die den Min/\+Max Wert enthalten soll \\
\hline
{\em as\+Column} & = Enhält den gewählten Aliasnamen für die Min/\+Max Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Boolean als Rückgabewert
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a39f437d3c3c841e8a82b9ad1b514007e}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Min\+Or\+Max\+Where@{select\+Min\+Or\+Max\+Where}}
\index{select\+Min\+Or\+Max\+Where@{select\+Min\+Or\+Max\+Where}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Min\+Or\+Max\+Where()}
{\footnotesize\ttfamily void select\+Min\+Or\+Max\+Where (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{min\+Or\+Max,  }\item[{std\+::string}]{min\+Or\+Max\+Column,  }\item[{std\+::string}]{alias\+Column,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Höchster / niedrigster Wert mit Bedingung und Alias-\/\+Spalte. 

Die Methode \char`\"{}select\+Min\+Or\+Max\+Where\char`\"{} ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte verknüpft mit einer Bedigungs Klausel und liefert die Alias-\/\+Spalte zurück.~\newline


S\+Q\+L-\/\+Befehl für das Minimum = \char`\"{}\+S\+E\+L\+E\+C\+T M\+I\+N(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} +\char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{};\char`\"{}~\newline
 S\+Q\+L-\/\+Befehl für das Maximum = \char`\"{}\+S\+E\+L\+E\+C\+T M\+A\+X(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} +\char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Enhält den Tabellennamen \\
\hline
{\em min\+Or\+Max} & = Gibt an welcher Befehl ausgeführt werden soll. \\
\hline
{\em min\+Or\+Max\+Column} & = Gibt die Spalte an, die den Min/\+Max Wert enthalten soll \\
\hline
{\em alias\+Column} & = Enhält den gewählten Aliasnamen für die Min/\+Max Spalte \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enhält den Bedigungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Boolean als Rückgabewert
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_aab8b32ae4ac6aeddc5c05578b4c79ace}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Not\+Like@{select\+Not\+Like}}
\index{select\+Not\+Like@{select\+Not\+Like}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Not\+Like()}
{\footnotesize\ttfamily void select\+Not\+Like (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{to\+Search\+Column,  }\item[{std\+::string}]{pattern,  }\item[{std\+::string}]{to\+Search }\end{DoxyParamCaption})}



Suche nach Muster. 

Die Methode \char`\"{}select\+Not\+Like\char`\"{} ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.~\newline
 Muster\+: Findet einen Datzensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} beginnt.~\newline
 Findet einen Datzensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} endet.~\newline
 Findet einen Datensatz der z.\+b nicht ein \char`\"{}or\char`\"{} an beliebiger Positon enhält. ~\newline
 Findet einen Datensatz der z.\+B nicht ein \char`\"{}r\char`\"{} an der zweiten Position enthält.~\newline
 Findet einen Datensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} beginnt und einem O anfängt.~\newline
 -\/$>$(Bedingung nur bei zwei Buchstaben erfüllt -\/$>$ Fehlermeldung bei mehr als zwei Buchstaben)~\newline


S\+Q\+L-\/\+Befehl\+:


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em to\+Search\+Column} & = Enthält die zu suchende Spalte \\
\hline
{\em pattern} & = enhält das ausgewählte Muster \\
\hline
{\em to\+Search} & = enhält das zu suchende Element\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Boolean als Rückgabewert
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_aedcd1503abb6715de26a92d34714dcce}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Null@{select\+Null}}
\index{select\+Null@{select\+Null}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Null()}
{\footnotesize\ttfamily void select\+Null (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_aff2cca0ae3f40a8b3ec70e85702bb8fc}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Right\+Join@{select\+Right\+Join}}
\index{select\+Right\+Join@{select\+Right\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Right\+Join()}
{\footnotesize\ttfamily void select\+Right\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a6a41ec41130fdce3f2c4dd701438f26a}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Sort\+Table@{select\+Sort\+Table}}
\index{select\+Sort\+Table@{select\+Sort\+Table}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Sort\+Table()}
{\footnotesize\ttfamily void select\+Sort\+Table (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{to\+Sort\+Column\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Tabelle wird nach Angabe sortiert. 

Mithilfe der \char`\"{}select\+Sort\+Table\char`\"{} Methode wird eine angebene Tabelle nach einer angebenen Spalte auf-\/ bzw. -\/\+Absteigend sortiert.~\newline
 Die ganze Tabelle wird ausgebenen.~\newline


S\+Q\+L-\/\+Befehl für A\+SC = \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} A\+S\+C;\char`\"{} S\+Q\+L-\/\+Befehl für D\+E\+SC = \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} D\+E\+S\+C;\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em to\+Sort\+Column\+Name} & = Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a9f37b58ba921dc5e6b5d4a5d0fefe28e}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Sum@{select\+Sum}}
\index{select\+Sum@{select\+Sum}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Sum()}
{\footnotesize\ttfamily void select\+Sum (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name,  }\item[{std\+::string}]{alias\+Column\+Name }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a3ac5ebbcfb624dc5178315c85c4b15fa}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Table\+Alias@{select\+Table\+Alias}}
\index{select\+Table\+Alias@{select\+Table\+Alias}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Table\+Alias()}
{\footnotesize\ttfamily void select\+Table\+Alias (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{alias\+Table\+Name }\end{DoxyParamCaption})}

\mbox{\label{selection_request_8cpp_a90eb635de3f1856a45557b42f18eff28}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where@{select\+Where}}
\index{select\+Where@{select\+Where}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where()}
{\footnotesize\ttfamily void select\+Where (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Anzeigen bestimmter Datensätze mit dem Zusatz der Where-\/\+Clause. 

Mithilfe der \char`\"{}select\+Where\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Die Funktion gibt ein void zurück -\/$>$ to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a519933061d4010c3a8d743b7e9fa9939}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where\+One\+Column@{select\+Where\+One\+Column}}
\index{select\+Where\+One\+Column@{select\+Where\+One\+Column}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where\+One\+Column()}
{\footnotesize\ttfamily void select\+Where\+One\+Column (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Bestimmte Datensätze von bestimmten Spalten abfragen. 

Mithilfe der \char`\"{}select\+One\+Column\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Es wird nur die Spalte angzeigt, wo der Datensatz verglichen worden ist.

S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \char`\"{} + \char`\"{}\textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void  Die Funktion gibt ein void zurück -\/$>$ to Do sollte einen Boolean zurückgeben, ob der Befehl erfolgreich bearbeitet wurde.
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a94269766ff6e39ba8a38f5623314c3cd}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where\+Order\+By@{select\+Where\+Order\+By}}
\index{select\+Where\+Order\+By@{select\+Where\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where\+Order\+By()}
{\footnotesize\ttfamily void select\+Where\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::string}]{to\+Sortcolumn\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Abfrage von Spalten mit Sortierung. 

Mithilfe der \char`\"{}select\+Where\+Order\+By\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt. Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat. Zudem wird es Aufsteigend oder Absteigend sortiert.

S\+Q\+L-\/\+Befehl für A\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} A\+S\+C;\char`\"{} S\+Q\+L-\/\+Befehl für D\+E\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} D\+E\+S\+C;\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & =Enhält den Bedingungswert \\
\hline
{\em to\+Sort\+Column\+Name} & =Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
\begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a51d8bd3191c8ab6e4acdc8053a05a3f5}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!sql\+Command@{sql\+Command}}
\index{sql\+Command@{sql\+Command}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{sql\+Command()}
{\footnotesize\ttfamily void sql\+Command (\begin{DoxyParamCaption}\item[{std\+::string}]{sql\+Command,  }\item[{std\+::string}]{command\+Type }\end{DoxyParamCaption})}



Benutzereigener S\+Q\+L-\/\+Befehl. 

Die Methode \char`\"{}sql\+Command\char`\"{} gibt einen vom Nutzer eingegebenen String(\+S\+Q\+L Befehl) direkt weiter zum S\+QL Server, zu dem wird der Befehlstyp unterschieden. Es wird zwischen 3 Befehlstypen unterschieden\+: Query -\/$>$ simple Abfrage an den S\+QL Server feedback-\/$>$ zeigt den Inhalt einer Spalte an feedback\+All-\/$>$ zeigt die komplette Tabelle mit Spaltenbezeichnugen an


\begin{DoxyParams}{Parameter}
{\em sql\+Command} & = enthält dem vom Nutzer eingegebenen String der später als S\+QL Befehl fungiert \\
\hline
{\em command\+Type} & = enhält dem vom Nutzer gewählten Befehlstyp\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void
\end{DoxyReturn}
Boolean als return \begin{DoxyAuthor}{Autor}
Martin Meyer 

Steffen Extra 
\end{DoxyAuthor}
\mbox{\label{selection_request_8cpp_a1bde570da9c90a3d0f6e94bc1b06c5e3}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!union\+Select@{union\+Select}}
\index{union\+Select@{union\+Select}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{union\+Select()}
{\footnotesize\ttfamily void union\+Select (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{column\+Name }\end{DoxyParamCaption})}

