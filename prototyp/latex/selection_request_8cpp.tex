\section{selection\+Request.\+cpp-\/\+Dateireferenz}
\label{selection_request_8cpp}\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}}
{\ttfamily \#include \char`\"{}sqllib.\+hpp\char`\"{}}\newline
Include-\/\+Abhängigkeitsdiagramm für selection\+Request.\+cpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Funktionen}
\begin{DoxyCompactItemize}
\item 
void \textbf{ own\+Command} (std\+::string sql\+Command, std\+::string command\+Type)
\begin{DoxyCompactList}\small\item\em Benutzereigener S\+Q\+L-\/\+Befehl. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Like} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string to\+Search\+Column, std\+::string pattern, std\+::string to\+Search)
\begin{DoxyCompactList}\small\item\em Suche nach Muster. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Not\+Like} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string to\+Search\+Column, std\+::string pattern, std\+::string to\+Search)
\begin{DoxyCompactList}\small\item\em Suche nach Muster. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Min\+Or\+Max} (std\+::string table\+Name, std\+::string min\+Or\+Max, std\+::string min\+Or\+Max\+Column, std\+::string alias\+Column)
\begin{DoxyCompactList}\small\item\em Ermittlung des höchsten / niedrigsten Wertes. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Min\+Or\+Max\+Where} (std\+::string table\+Name, std\+::string min\+Or\+Max, std\+::string min\+Or\+Max\+Column, std\+::string alias\+Column, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Höchster / niedrigster Wert mit Bedingung und Alias-\/\+Spalte. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Limit\+Where\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string limit\+Number, std\+::string condition\+Column, std\+::string condition\+Value, std\+::string to\+Sort\+Column\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Where\+One\+Column} (std\+::string table\+Name, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Bestimmte Datensätze von bestimmten Spalten abfragen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Where} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string condition\+Column, std\+::string condition\+Value)
\begin{DoxyCompactList}\small\item\em Anzeigen bestimmter Datensätze mit dem Zusatz der Where-\/\+Clause. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Bool} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::vector$<$ std\+::string $>$conditions, std\+::vector$<$ std\+::string $>$condition\+Value, std\+::vector$<$ std\+::string $>$ conditions2, std\+::vector$<$ std\+::string $>$condition\+Value2, std\+::vector$<$ std\+::string $>$operators)
\begin{DoxyCompactList}\small\item\em Where-\/\+Clause mit mehreren Bedingungen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Where\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::string to\+Sortcolumn\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Abfrage von Spalten mit Sortierung. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Sort\+Table} (std\+::string table\+Name, std\+::string to\+Sort\+Column\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Tabelle wird nach Angabe sortiert. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Count} (std\+::string table\+Name, std\+::string count\+Column, std\+::string alias\+Column\+Name)
\begin{DoxyCompactList}\small\item\em Anzahl von ausgewählten Datensätzen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Distinct} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$ columns)
\begin{DoxyCompactList}\small\item\em Redundanzen werden eliminiert und nur einmal angezeigt. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Count\+Distinct} (std\+::string table\+Name, std\+::string count\+Column)
\begin{DoxyCompactList}\small\item\em Keine Redundanzen / Datensätze werden gezählt. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Average\+Sum} (std\+::string table\+Name, std\+::string column\+Name)
\begin{DoxyCompactList}\small\item\em Durchschnittswert. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Sum} (std\+::string table\+Name, std\+::string column\+Name, std\+::string alias\+Column\+Name)
\begin{DoxyCompactList}\small\item\em Summieren von Werten. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Union} (std\+::vector$<$ std\+::string $>$ table\+Name, std\+::vector$<$ std\+::string $>$ column\+Name)
\begin{DoxyCompactList}\small\item\em Vereinigung zweier Abfragen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+In} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string search\+In\+Column, std\+::vector$<$ std\+::string $>$condition\+Value)
\begin{DoxyCompactList}\small\item\em Mehrere Abfrageergebnisse bündeln. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Between} (std\+::string condition\+String, std\+::string condition\+String\+Two, std\+::string table\+Name, std\+::string condition\+Column, std\+::string condition\+Column\+Two, std\+::string condition, std\+::string condition\+Two)
\begin{DoxyCompactList}\small\item\em Eingeschränkte Abfragen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Columns\+Alias} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::vector$<$ std\+::string $>$aliases)
\begin{DoxyCompactList}\small\item\em Alias-\/\+Spaltennamen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Table\+Alias} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string alias\+Table\+Name)
\begin{DoxyCompactList}\small\item\em Zuweisung eines Alias. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Group\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns)
\begin{DoxyCompactList}\small\item\em Gruppieren von Ergebnismengen. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Group\+By\+Order\+By} (std\+::string table\+Name, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns, std\+::string to\+Sortcolumn\+Name, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Ergebnismengen + sortieren. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Count\+Group\+By\+Order\+By} (std\+::string table\+Name, std\+::string count\+Column, std\+::vector$<$ std\+::string $>$columns, std\+::string condition\+Column, std\+::string condition\+Value, std\+::vector$<$ std\+::string $>$group\+By\+Columns, std\+::string sort\+By)
\begin{DoxyCompactList}\small\item\em Ergebnismengen gruppieren + zählen der Datensätze + Sortierung. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Null} (std\+::string table\+Name, std\+::string column\+Name)
\begin{DoxyCompactList}\small\item\em N\+U\+LL Werte. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Inner\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\begin{DoxyCompactList}\small\item\em Inner\+Join-\/\+Befehl. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Left\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\begin{DoxyCompactList}\small\item\em Left\+Join Methode. \end{DoxyCompactList}\item 
std\+::string \textbf{ select\+Right\+Join} (std\+::string first\+Table\+Name, std\+::string column\+I\+D\+Table\+One, std\+::vector$<$ std\+::string $>$ columns\+Table\+One, std\+::string second\+Table\+Name, std\+::vector$<$ std\+::string $>$ columns\+Table\+Two)
\end{DoxyCompactItemize}


\subsection{Dokumentation der Funktionen}
\mbox{\label{selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!own\+Command@{own\+Command}}
\index{own\+Command@{own\+Command}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{own\+Command()}
{\footnotesize\ttfamily void own\+Command (\begin{DoxyParamCaption}\item[{std\+::string}]{sql\+Command,  }\item[{std\+::string}]{command\+Type }\end{DoxyParamCaption})}



Benutzereigener S\+Q\+L-\/\+Befehl. 

Die Methode \char`\"{}sql\+Command\char`\"{} gibt einen vom Nutzer eingegebenen String(\+S\+Q\+L Befehl) direkt weiter zum S\+QL Server, zu dem wird der Befehlstyp unterschieden. Es wird zwischen 3 Befehlstypen unterschieden\+: Query -\/$>$ simple Abfrage an den S\+QL Server feedback-\/$>$ zeigt den Inhalt einer Spalte an feedback\+All-\/$>$ zeigt die komplette Tabelle mit Spaltenbezeichnugen an


\begin{DoxyParams}{Parameter}
{\em sql\+Command} & = enthält dem vom Nutzer eingegebenen String der später als S\+QL Befehl fungiert \\
\hline
{\em command\+Type} & = enhält dem vom Nutzer gewählten Befehlstyp\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
void 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a1909c1b8666cf6e3d31a014c9a9ad2d7_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a0c0b74ea6569aa25068b80d57061e864}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Average\+Sum@{select\+Average\+Sum}}
\index{select\+Average\+Sum@{select\+Average\+Sum}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Average\+Sum()}
{\footnotesize\ttfamily std\+::string select\+Average\+Sum (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name }\end{DoxyParamCaption})}



Durchschnittswert. 

Die \char`\"{}select\+Average\+Sum\char`\"{} Methode berechnet den Durchschnittswert aller Werte, die in einer Spalte mittels einer Select-\/\+Abfrage ermitteln wurden.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T A\+V\+G(\char`\"{} + column\+Name + \char`\"{}) F\+R\+O\+M \char`\"{} + table\+Name;


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em column\+Name} & = Enthält den Spaltennamen von der, der Durchschnitt berechnet werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a0c0b74ea6569aa25068b80d57061e864_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a5497ea7a5b36b35ae8f08ce374790858}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Between@{select\+Between}}
\index{select\+Between@{select\+Between}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Between()}
{\footnotesize\ttfamily std\+::string select\+Between (\begin{DoxyParamCaption}\item[{std\+::string}]{condition\+String,  }\item[{std\+::string}]{condition\+String\+Two,  }\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Column\+Two,  }\item[{std\+::string}]{condition,  }\item[{std\+::string}]{condition\+Two }\end{DoxyParamCaption})}



Eingeschränkte Abfragen. 

Die \char`\"{}select\+Between\char`\"{} Methode beinhält die S\+Q\+L-\/\+Where Bedingungen mit einem eingeschränkten und bestimmten Bereich eines Abfrageergebnisses.~\newline


S\+Q\+L-\/\+Befehl\+: S\+E\+L\+E\+CT $\ast$ \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} \char`\"{} + condition\+String + \char`\"{} \char`\"{} + condition
\begin{DoxyItemize}
\item \char`\"{} A\+N\+D \char`\"{} + condition\+Column\+Two + \char`\"{} \char`\"{} + condition\+String + \char`\"{} \char`\"{} + condition\+Two;
\end{DoxyItemize}


\begin{DoxyParams}{Parameter}
{\em condition\+String} & = Bedingung (Name = ...) \\
\hline
{\em condition\+String\+Two} & = Bedingung (Name = ...) \\
\hline
{\em tablen\+Name} & = Name der Tabelle \\
\hline
{\em condition\+Column} & = Spalte der ersten Bedingung \\
\hline
{\em condition\+Column2} & = Spalte der zweiten Bedingung \\
\hline
{\em condition} & = Bedingung (... = \textquotesingle{}Hans\textquotesingle{}) \\
\hline
{\em condition\+Two} & = Bedingung (... = \char`\"{}\+Hans\char`\"{})\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a5497ea7a5b36b35ae8f08ce374790858_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a8c1eb741cc480c74a0042e9689c04a94}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Bool@{select\+Bool}}
\index{select\+Bool@{select\+Bool}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Bool()}
{\footnotesize\ttfamily std\+::string select\+Bool (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::vector$<$ std\+::string $>$}]{conditions,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{conditions2,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value2,  }\item[{std\+::vector$<$ std\+::string $>$}]{operators }\end{DoxyParamCaption})}



Where-\/\+Clause mit mehreren Bedingungen. 

Mithilfe der \char`\"{}select\+Bool\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Zudem kann man ,dank der Funktion mit mehrere Bool-\/\+Bedingungen verknüpfen.~\newline
 Es werden zwei Bedignungsspalten Vektoren, zwei Bedingungswert\+Vektoren sowieo ein Vektor der die Operationen enhält übergeben.~\newline
 Ein Schleifendurchlauf holt sich die zwei Namen der Bedingungsspalten sowie die beiden Bedingungswerte dazu wird dann der boolische Operator hinzugefügt.~\newline
 Die beiden Conditionsvektoren müssen gleich groß sein.~\newline
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Operator\+String + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert \\
\hline
{\em condition\+Column2} & = Enthält den Namen der zweiten zu vergleichnen Bedingungsspalte \\
\hline
{\em condition\+Value2} & = Enthält den zweiten zu vergleichnenen Bedingungswert \\
\hline
{\em operators} & = Enthält die Liste der boolischen Ausdrücke\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a8c1eb741cc480c74a0042e9689c04a94_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a3eea3cd04977d9873801490d0fbec14a}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Columns\+Alias@{select\+Columns\+Alias}}
\index{select\+Columns\+Alias@{select\+Columns\+Alias}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Columns\+Alias()}
{\footnotesize\ttfamily std\+::string select\+Columns\+Alias (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::vector$<$ std\+::string $>$}]{aliases }\end{DoxyParamCaption})}



Alias-\/\+Spaltennamen. 

Die \char`\"{}select\+Columns\+Alias\char`\"{} Methode kann für übergebene Spalte(n) einen ausgwählten Alias-\/\+Spaltenname(n) hinzufügen.~\newline


Zuordnung\+: Spaltenname(i) = Alias-\/\+Spaltennamen(i)~\newline



\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der zu anzeigenen \& zu unbennenen Spalten \\
\hline
{\em aliases} & = Enthält die Liste mit den Aliasnamen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a3eea3cd04977d9873801490d0fbec14a_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_aca36da6198b8c35ba721a68a51cd8898}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count@{select\+Count}}
\index{select\+Count@{select\+Count}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count()}
{\footnotesize\ttfamily std\+::string select\+Count (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column,  }\item[{std\+::string}]{alias\+Column\+Name }\end{DoxyParamCaption})}



Anzahl von ausgewählten Datensätzen. 

Die select\+Count Methode zählt(\+C\+O\+U\+N\+T) die Anzahl von ausgewählten Datensätzen.~\newline
 Es werden alle Datensätze gezählt, deren Wert nicht N\+U\+LL ist. ~\newline
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\char`\"{} + count\+Column + \char`\"{}) A\+S \char`\"{} + alias\+Column\+Name + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em count\+Column} & = Enthält die zu zählende Spalte \\
\hline
{\em alias\+Column} & = Enthält den gewählten Aliasnamen für die zurückgegebene Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_aca36da6198b8c35ba721a68a51cd8898_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a118df4625d0eec25ad2215f028520f72}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count\+Distinct@{select\+Count\+Distinct}}
\index{select\+Count\+Distinct@{select\+Count\+Distinct}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count\+Distinct()}
{\footnotesize\ttfamily std\+::string select\+Count\+Distinct (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column }\end{DoxyParamCaption})}



Keine Redundanzen / Datensätze werden gezählt. 

Mithilfe der \char`\"{}select\+Count\+Distinct\char`\"{} Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt und anschließend werden diese Datensätze gezählt.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\+D\+I\+S\+T\+I\+N\+C\+T \char`\"{} + count\+Column + \char`\"{}) F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em count\+Column} & = Enthält die zu zählende Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a118df4625d0eec25ad2215f028520f72_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_ab115e996b276802329fb8d2899c6d44d}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Count\+Group\+By\+Order\+By@{select\+Count\+Group\+By\+Order\+By}}
\index{select\+Count\+Group\+By\+Order\+By@{select\+Count\+Group\+By\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Count\+Group\+By\+Order\+By()}
{\footnotesize\ttfamily std\+::string select\+Count\+Group\+By\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{count\+Column,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Ergebnismengen gruppieren + zählen der Datensätze + Sortierung. 

Mithilfe der \char`\"{}select\+Count\+Group\+By\+Order\+By\char`\"{} Methode ist es möglich die Ergebnismenge zu gruppieren. ~\newline
 Das Count zählt die Anzahl der gruppierten Ergebnismengen. Es werden alle Datensätze gezählt, deren Wert nicht N\+U\+LL ist. ~\newline
 Zudem kann der Datensatz anschließend auf-\/ bzw. Absteigend sortiert werden. ~\newline


S\+Q\+L-\/\+Befehl A\+SC\+: std\+::string sql\+Command =\char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\char`\"{} + count\+Column +\char`\"{}),\char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{} G\+R\+O\+U\+P B\+Y \char`\"{} + all\+Group\+By\+Columns + \char`\"{} O\+R\+D\+E\+R B\+Y C\+O\+U\+N\+T(\char`\"{} + count\+Column +\char`\"{}) A\+S\+C;\char`\"{} S\+Q\+L-\/\+Befehl D\+E\+SC\+: std\+::string sql\+Command =\char`\"{}\+S\+E\+L\+E\+C\+T C\+O\+U\+N\+T(\char`\"{} + count\+Column +\char`\"{}),\char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{} G\+R\+O\+U\+P B\+Y \char`\"{} + all\+Group\+By\+Columns + \char`\"{} O\+R\+D\+E\+R B\+Y C\+O\+U\+N\+T(\char`\"{} + count\+Column +\char`\"{}) D\+E\+S\+C;\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle , count\+Column = Enthält die zu zählende Spalte \\
\hline
{\em columns} & = Enthält die Liste der zu anzeigenen \& zu unbennenen Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert \\
\hline
{\em group\+By\+Columns} & = Enthält die Liste der zu gruppierenden Spaltennamen \\
\hline
{\em to\+Sort\+Column\+Name} & = Enthält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_ab115e996b276802329fb8d2899c6d44d_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_aaad6e80fc6076afccfdccd194889aa92}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Distinct@{select\+Distinct}}
\index{select\+Distinct@{select\+Distinct}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Distinct()}
{\footnotesize\ttfamily std\+::string select\+Distinct (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns }\end{DoxyParamCaption})}



Redundanzen werden eliminiert und nur einmal angezeigt. 

Mithilfe der \char`\"{}select\+Distinct\char`\"{} Methode werden Redundanzen, die in einer Tabellen auftreten können, eliminiert und die Werte werden jeweils nur einmal angezeigt.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T D\+I\+S\+T\+I\+N\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em column} & = Enthält die Liste der angezeigten Spalten\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_aaad6e80fc6076afccfdccd194889aa92_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a70f6716adfb73ac0b427b3f264b6d848}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Group\+By@{select\+Group\+By}}
\index{select\+Group\+By@{select\+Group\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Group\+By()}
{\footnotesize\ttfamily std\+::string select\+Group\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns }\end{DoxyParamCaption})}



Gruppieren von Ergebnismengen. 

Mithilfe der \char`\"{}select\+Group\+By\char`\"{} Methode ist es möglich eine Ergebnismenge zu gruppieren.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{} G\+R\+O\+U\+P B\+Y \char`\"{} + all\+Group\+By\+Columns + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name-\/$>$} & Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der zu anzeigenen \& zu unbennenen Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert \\
\hline
{\em group\+By\+Columns} & = Enhält die Liste der zu gruppierenden Spaltennamen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a70f6716adfb73ac0b427b3f264b6d848_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a4626b3e4c6a6a456371f2cddc13ffb7a}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Group\+By\+Order\+By@{select\+Group\+By\+Order\+By}}
\index{select\+Group\+By\+Order\+By@{select\+Group\+By\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Group\+By\+Order\+By()}
{\footnotesize\ttfamily std\+::string select\+Group\+By\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::vector$<$ std\+::string $>$}]{group\+By\+Columns,  }\item[{std\+::string}]{to\+Sortcolumn\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Ergebnismengen + sortieren. 

Mithilfe der \char`\"{}select\+Group\+By\+Order\+By\char`\"{} Methode ist es möglich eine Ergebnismenge zu gruppieren und diese Auf-\/ bzw. Absteigend zu sortieren.~\newline


S\+Q\+L-\/\+Befehl für A\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{} G\+R\+O\+U\+P B\+Y \char`\"{} + all\+Group\+By\+Columns + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} A\+S\+C;\char`\"{}~\newline
 S\+Q\+L-\/\+Befehl für D\+E\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{} G\+R\+O\+U\+P B\+Y \char`\"{} + all\+Group\+By\+Columns + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} D\+E\+S\+C;\char`\"{}~\newline



\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enhält die Liste der zu anzeigenen \& zu unbennenen Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert \\
\hline
{\em group\+By\+Columns} & = Enthält die Liste der zu gruppierenden Spaltennamen \\
\hline
{\em to\+Sort\+Column\+Name} & = Enthält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a4626b3e4c6a6a456371f2cddc13ffb7a_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a56add7eeed983b8439e87e7814474dff}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+In@{select\+In}}
\index{select\+In@{select\+In}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+In()}
{\footnotesize\ttfamily std\+::string select\+In (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{search\+In\+Column,  }\item[{std\+::vector$<$ std\+::string $>$}]{condition\+Value }\end{DoxyParamCaption})}



Mehrere Abfrageergebnisse bündeln. 

Die \char`\"{}select\+In\char`\"{} Methode kann mehrere Abfrageergebnisse in einer S\+Q\+L-\/\+Anweisung zu bündeln.~\newline
 Damit kann der IN Operator leicht mehrere OR Operatoren ersetzen und vereinfacht damit die Struktur von komplexen O\+R-\/\+Bedingungen.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + search\+In\+Column + \char`\"{} I\+N \char`\"{} + \char`\"{} (\char`\"{} + comparativ\+Values + \char`\"{});\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em search\+In\+Column} & = Enthält den Spaltennamen in der die Werte vergleicht werden \\
\hline
{\em condition\+Value} & = Enthält eine Liste der zu vergleichenden Werten\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a56add7eeed983b8439e87e7814474dff_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a36f7b6465f35b2f96f04c33dec10afa2}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Inner\+Join@{select\+Inner\+Join}}
\index{select\+Inner\+Join@{select\+Inner\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Inner\+Join()}
{\footnotesize\ttfamily std\+::string select\+Inner\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}



Inner\+Join-\/\+Befehl. 

Mithilfe der \char`\"{}select\+Inner\+Join\char`\"{} Methode wird eine neue Ergebnistabelle erstellt.~\newline
 Durch Kombinieren von Spaltenwerten zweier Tabellen (first\+Table und second\+Table) basierend auf dem Join-\/\+Prädikat.~\newline
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2 um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.~\newline
 Wenn das Join-\/\+Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar Zeilen von A und B in einer Ergebniszeile zusammengefasst.~\newline
 Das Schlüsselwort I\+N\+N\+ER J\+O\+IN wählt Datensätze mit übereinstimmenden Werten in beiden Tabellen aus.~\newline


S\+Q\+L-\/\+Befehl\+: select $<$\+Auswahl$>$ F\+R\+OM TabelleA I\+N\+N\+ER J\+O\+IN TabelleB B ON A.\+ID = B.\+ID


\begin{DoxyParams}{Parameter}
{\em first\+Table\+Name} & = Name der ersten Tabelle \\
\hline
{\em column\+I\+D\+Table\+One} & = Enthält die zu vergleichene Spalte der ersten Tabelle \\
\hline
{\em columns\+Table\+One} & = Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen \\
\hline
{\em second\+Table\+Name} & = Enthält den Tabellennamen der zweiten Tabelle \\
\hline
{\em columns\+Table\+Two} & = Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a36f7b6465f35b2f96f04c33dec10afa2_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_ac2063212201f14978b1abb0c9b94a460}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Left\+Join@{select\+Left\+Join}}
\index{select\+Left\+Join@{select\+Left\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Left\+Join()}
{\footnotesize\ttfamily std\+::string select\+Left\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}



Left\+Join Methode. 

Mithilfe der \char`\"{}select\+Left\+Join\char`\"{} Methode wird eine neue Ergebnistabelle erstellt.~\newline
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (first\+Table und second\+Table) basierend auf dem Join-\/\+Prädikat.~\newline
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen.~\newline
 Wenn das Join-\/\+Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.~\newline
 Das Schlüsselwort L\+E\+FT J\+O\+IN gibt alle Datensätze der linken Tabelle (first\+Table) und die übereinstimmenden Datensätze der rechten Tabelle (second\+Table) zurück.~\newline
 Das Ergebnis ist N\+U\+LL von rechts, wenn keine Übereinstimmung vorliegt.~\newline


S\+Q\+L-\/\+Befehl\+: select $<$\+Auswahl$>$ F\+R\+OM TabelleA L\+E\+FT J\+O\+IN TabelleB B ON A.\+ID = B.\+ID


\begin{DoxyParams}{Parameter}
{\em first\+Table\+Name} & = Name der ersten Tabelle \\
\hline
{\em column\+I\+D\+Table\+One} & = Enthält die zu vergleichene Spalte der ersten Tabelle \\
\hline
{\em columns\+Table\+One} & = Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen \\
\hline
{\em second\+Table\+Name} & =Enthält den Tabellennamen der zweiten Tabelle \\
\hline
{\em columns\+Table\+Two} & = Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_ac2063212201f14978b1abb0c9b94a460_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a9b72023da3a86c491cef2d340bede35e}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Like@{select\+Like}}
\index{select\+Like@{select\+Like}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Like()}
{\footnotesize\ttfamily std\+::string select\+Like (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{to\+Search\+Column,  }\item[{std\+::string}]{pattern,  }\item[{std\+::string}]{to\+Search }\end{DoxyParamCaption})}



Suche nach Muster. 

Die Methode \char`\"{}select\+Like\char`\"{} ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.~\newline
 Muster\+: Findet einen Datzensatz der z.\+B mit einem \char`\"{}a\char`\"{} beginnt.~\newline
 Findet einen Datzensatz der z.\+B mit einem \char`\"{}a\char`\"{} endet.~\newline
 Findet einen Datensatz der z.\+b ein \char`\"{}or\char`\"{} an beliebiger Positon enhält. ~\newline
 Findet einen Datensatz der z.\+B ein \char`\"{}r\char`\"{} an der zweiten Position enthält.~\newline
 Findet einen Datensatz der z.\+B mit einem \char`\"{}a\char`\"{} beginnt und einem O anfängt. ~\newline
 -\/$>$(Bedingung nur bei zwei Buchstaben erfüllt -\/$>$ Fehlermeldung bei mehr als zwei Buchstaben)~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + to\+Search\+Column + \char`\"{}  L\+I\+K\+E \char`\"{} + \char`\"{}\textquotesingle{}\char`\"{} + to\+Search + \char`\"{}\%\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enhält die Liste der angezeigten Spalten \\
\hline
{\em to\+Search\+Column} & = Enhält die zu suchende Spalte \\
\hline
{\em pattern} & = enhält das ausgewählte Muster \\
\hline
{\em to\+Search} & = enhält das zu suchende Element\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a9b72023da3a86c491cef2d340bede35e_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a4a7a5336f56c689d43717ed65d216928}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Limit\+Where\+Order\+By@{select\+Limit\+Where\+Order\+By}}
\index{select\+Limit\+Where\+Order\+By@{select\+Limit\+Where\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Limit\+Where\+Order\+By()}
{\footnotesize\ttfamily std\+::string select\+Limit\+Where\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{limit\+Number,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::string}]{to\+Sort\+Column\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Bestimmte Anzahl von Datensätzen mit Bedingung abfragen. 

Die Methode \char`\"{}select\+Limit\+Where\char`\"{} dient dazu eine vom Nutzer festgelegte Anzahl an Datensätzen abzufragen, verknüpft mit einer Bedingungs Klausel. ~\newline
 Zudem wird es Aufsteigend bzw. Absteigend sotiert.~\newline


S\+Q\+L-\/\+Befehl A\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{}  O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} A\+S\+C \char`\"{} + \char`\"{} L\+I\+M\+I\+T \char`\"{} + limit\+Number + \char`\"{};\char`\"{}; S\+Q\+L-\/\+Befehl D\+E\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{}  O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} D\+E\+S\+C \char`\"{} + \char`\"{} L\+I\+M\+I\+T \char`\"{} + limit\+Number + \char`\"{};\char`\"{};


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em limit\+Number} & = Anzahl der angezeigten Datensätze \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enhält den Bedigungswert \\
\hline
{\em to\+Sort\+Column\+Name} & = Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & =Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a4a7a5336f56c689d43717ed65d216928_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_acf929efd37e4b717717d99807cfe41e2}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Min\+Or\+Max@{select\+Min\+Or\+Max}}
\index{select\+Min\+Or\+Max@{select\+Min\+Or\+Max}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Min\+Or\+Max()}
{\footnotesize\ttfamily std\+::string select\+Min\+Or\+Max (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{min\+Or\+Max,  }\item[{std\+::string}]{min\+Or\+Max\+Column,  }\item[{std\+::string}]{alias\+Column }\end{DoxyParamCaption})}



Ermittlung des höchsten / niedrigsten Wertes. 

Die Methode \char`\"{}select\+Min\+Or\+Max\char`\"{} ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte und liefert die Spalte mit einem Aliasnamen zurück.~\newline


S\+Q\+L-\/\+Befehl für das Minimum\+: \char`\"{}\+S\+E\+L\+E\+C\+T M\+I\+N(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} + \char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{} S\+Q\+L-\/\+Befehl für das Maximum\+: \char`\"{}\+S\+E\+L\+E\+C\+T M\+A\+X(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} + \char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em min\+Or\+Max} & = Gibt an welcher Befehl ausgeführt werden soll. \\
\hline
{\em min\+Or\+Max\+Column} & = Gibt die Spalte an, die den Min/\+Max Wert enthalten soll \\
\hline
{\em as\+Column} & = Enhält den gewählten Aliasnamen für die Min/\+Max Spalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_acf929efd37e4b717717d99807cfe41e2_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_aba0d2e1188ed35207922e408c0f366fc}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Min\+Or\+Max\+Where@{select\+Min\+Or\+Max\+Where}}
\index{select\+Min\+Or\+Max\+Where@{select\+Min\+Or\+Max\+Where}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Min\+Or\+Max\+Where()}
{\footnotesize\ttfamily std\+::string select\+Min\+Or\+Max\+Where (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{min\+Or\+Max,  }\item[{std\+::string}]{min\+Or\+Max\+Column,  }\item[{std\+::string}]{alias\+Column,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Höchster / niedrigster Wert mit Bedingung und Alias-\/\+Spalte. 

Die Methode \char`\"{}select\+Min\+Or\+Max\+Where\char`\"{} ermittelt den höchsten bzw. niedrigsten Wert einer Tabellenspalte verknüpft mit einer Bedigungs Klausel und liefert die Alias-\/\+Spalte zurück.~\newline


S\+Q\+L-\/\+Befehl für das Minimum = \char`\"{}\+S\+E\+L\+E\+C\+T M\+I\+N(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} +\char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{};\char`\"{}~\newline
 S\+Q\+L-\/\+Befehl für das Maximum = \char`\"{}\+S\+E\+L\+E\+C\+T M\+A\+X(\char`\"{} + min\+Or\+Max\+Column +\char`\"{})\char`\"{} +\char`\"{} A\+S \char`\"{} + alias\+Column + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Enhält den Tabellennamen \\
\hline
{\em min\+Or\+Max} & = Gibt an welcher Befehl ausgeführt werden soll. \\
\hline
{\em min\+Or\+Max\+Column} & = Gibt die Spalte an, die den Min/\+Max Wert enthalten soll \\
\hline
{\em alias\+Column} & = Enhält den gewählten Aliasnamen für die Min/\+Max Spalte \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enhält den Bedigungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_aba0d2e1188ed35207922e408c0f366fc_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_ac5d1f449131f10de07406afce2eca45f}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Not\+Like@{select\+Not\+Like}}
\index{select\+Not\+Like@{select\+Not\+Like}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Not\+Like()}
{\footnotesize\ttfamily std\+::string select\+Not\+Like (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{to\+Search\+Column,  }\item[{std\+::string}]{pattern,  }\item[{std\+::string}]{to\+Search }\end{DoxyParamCaption})}



Suche nach Muster. 

Die Methode \char`\"{}select\+Not\+Like\char`\"{} ermöglicht eine Suche auf der Grundlage eines vorher definierten regulären Musters.~\newline
 Muster\+: Findet einen Datzensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} beginnt.~\newline
 Findet einen Datzensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} endet.~\newline
 Findet einen Datensatz der z.\+b nicht ein \char`\"{}or\char`\"{} an beliebiger Positon enhält. ~\newline
 Findet einen Datensatz der z.\+B nicht ein \char`\"{}r\char`\"{} an der zweiten Position enthält.~\newline
 Findet einen Datensatz der z.\+B nicht mit einem \char`\"{}a\char`\"{} beginnt und einem O anfängt.~\newline
 -\/$>$(Bedingung nur bei zwei Buchstaben erfüllt -\/$>$ Fehlermeldung bei mehr als zwei Buchstaben)~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + to\+Search\+Column + \char`\"{} N\+O\+T L\+I\+K\+E \char`\"{} + \char`\"{}\textquotesingle{}\char`\"{} + to\+Search + \char`\"{}\%\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em to\+Search\+Column} & = Enthält die zu suchende Spalte \\
\hline
{\em pattern} & = enhält das ausgewählte Muster \\
\hline
{\em to\+Search} & = enhält das zu suchende Element\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_ac5d1f449131f10de07406afce2eca45f_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a0972bc18453bc3a60f21f0f629fddf52}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Null@{select\+Null}}
\index{select\+Null@{select\+Null}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Null()}
{\footnotesize\ttfamily std\+::string select\+Null (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name }\end{DoxyParamCaption})}



N\+U\+LL Werte. 

Die select\+Null Methode prüft eine Spalte auf den Wert N\+U\+LL.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ \char`\"{} + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + column\+Name + \char`\"{} I\+S N\+U\+L\+L\char`\"{} + \char`\"{} O\+R \textquotesingle{} \textquotesingle{}; \char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em Column\+Name} & = Enhält den Namen der Bedingungsspalte\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a0972bc18453bc3a60f21f0f629fddf52_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a139ed7a657cf0e77c9e30ff75fbf4a49}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Right\+Join@{select\+Right\+Join}}
\index{select\+Right\+Join@{select\+Right\+Join}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Right\+Join()}
{\footnotesize\ttfamily std\+::string select\+Right\+Join (\begin{DoxyParamCaption}\item[{std\+::string}]{first\+Table\+Name,  }\item[{std\+::string}]{column\+I\+D\+Table\+One,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+One,  }\item[{std\+::string}]{second\+Table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns\+Table\+Two }\end{DoxyParamCaption})}

Mithilfe der \char`\"{}select\+Right\+Join\char`\"{} Methode wird eine neue Ergebnistabelle erstellt.~\newline
 Durch Kombinieren von Spaltenwerten von zwei Tabellen (first\+Table und second\+Table) basierend auf dem Join-\/\+Prädikat. ~\newline
 Die Abfrage vergleicht jede Zeile von table1 mit jeder Zeile von table2, um alle Zeilenpaare zu finden, die das Verknüpfungsprädikat erfüllen. ~\newline
 Wenn das Join-\/\+Prädikat erfüllt ist, werden Spaltenwerte für jedes übereinstimmende Paar von Zeilen von A und B in einer Ergebniszeile zusammengefasst.~\newline
 Das Schlüsselwort R\+I\+G\+HT J\+O\+IN gibt alle Datensätze der rechten Tabelle (second\+Table) und die übereinstimmenden Datensätze der linken Tabelle (first\+Table) zurück. ~\newline
 Das Ergebnis ist N\+U\+LL von links, wenn keine Übereinstimmung vorliegt.~\newline


S\+Q\+L-\/\+Befehl\+: select $<$\+Auswahl$>$ F\+R\+OM TabelleA L\+E\+FT J\+O\+IN TabelleB B ON A.\+ID = B.\+ID


\begin{DoxyParams}{Parameter}
{\em first\+Table\+Name} & = Name der ersten Tabelle  = Enthält die zu vergleichene Spalte der ersten Tabelle \\
\hline
{\em columns\+Table\+One} & = Enthält die Liste der Spalten die aus der ersten Tabelle angezeigt werden sollen \\
\hline
{\em second\+Table\+Name} & = Name der zweiten Tabelle \\
\hline
{\em columns\+Table\+Two} & = Enthält die Liste der Spalten die aus der zweiten Tabelle angezeigt werden sollen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a139ed7a657cf0e77c9e30ff75fbf4a49_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a171b9c43b31e26dd2c30acb9344d2da8}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Sort\+Table@{select\+Sort\+Table}}
\index{select\+Sort\+Table@{select\+Sort\+Table}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Sort\+Table()}
{\footnotesize\ttfamily std\+::string select\+Sort\+Table (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{to\+Sort\+Column\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Tabelle wird nach Angabe sortiert. 

Mithilfe der \char`\"{}select\+Sort\+Table\char`\"{} Methode wird eine angebene Tabelle nach einer angebenen Spalte auf-\/ bzw. -\/\+Absteigend sortiert.~\newline
 Die ganze Tabelle wird ausgebenen.~\newline


S\+Q\+L-\/\+Befehl für A\+SC = \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} A\+S\+C;\char`\"{} S\+Q\+L-\/\+Befehl für D\+E\+SC = \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sort\+Column\+Name + \char`\"{} D\+E\+S\+C;\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em to\+Sort\+Column\+Name} & = Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a171b9c43b31e26dd2c30acb9344d2da8_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a8da8323e6a01c3f2ed669dccd7bf2854}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Sum@{select\+Sum}}
\index{select\+Sum@{select\+Sum}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Sum()}
{\footnotesize\ttfamily std\+::string select\+Sum (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{column\+Name,  }\item[{std\+::string}]{alias\+Column\+Name }\end{DoxyParamCaption})}



Summieren von Werten. 

Die \char`\"{}select\+Sum\char`\"{} Methode summiert die Werte einer Tabellenspalte und liefert sie zurück.~\newline
 Zudem wird die zurück gegebene Spalte mit einem vom Nutzer bestimmten Aliasnamen versehen.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T S\+U\+M(\char`\"{} + column\+Name + \char`\"{}) A\+S \char`\"{} + alias\+Column\+Name+ \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name;


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em column\+Name} & = Enthält den Spaltennamen von der, die Summe berechnet werden soll \\
\hline
{\em alias\+Column\+Name} & = Enthält den Aliasnamen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a8da8323e6a01c3f2ed669dccd7bf2854_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_aa6e291bc8aca21c19e88231d4de51b70}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Table\+Alias@{select\+Table\+Alias}}
\index{select\+Table\+Alias@{select\+Table\+Alias}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Table\+Alias()}
{\footnotesize\ttfamily std\+::string select\+Table\+Alias (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{alias\+Table\+Name }\end{DoxyParamCaption})}



Zuweisung eines Alias. 

Die \char`\"{}select\+Table\+Alias\char`\"{} Methode kann der übergebenen Tabelle einen Alias-\/\+Tabellennamen zuweisen.

S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + column\+Alias + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} A\+S \char`\"{} + alias\+Table\+Name +\char`\"{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der zu anzeigenen Spalten \\
\hline
{\em alias\+Tabellennamen} & = Enthält den Alias-\/\+Tabellennamen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_aa6e291bc8aca21c19e88231d4de51b70_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a1dc6e0b39020c0e1877be2e183e2e049}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Union@{select\+Union}}
\index{select\+Union@{select\+Union}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Union()}
{\footnotesize\ttfamily std\+::string select\+Union (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{column\+Name }\end{DoxyParamCaption})}



Vereinigung zweier Abfragen. 

Die \char`\"{}union\+Select\char`\"{} Methode vereinigt die Ergebnisse zweier Abfragen.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + column\+Name.\+at(i) + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name.\+at(i) + \char`\"{} U\+N\+I\+O\+N \char`\"{};


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Enthält die Liste der Tabellennamen \\
\hline
{\em column\+Name} & = Enthält die Liste der Spaltennamen\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a1dc6e0b39020c0e1877be2e183e2e049_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a7caa0e0e66c9c4cadc4ec5d596bba565}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where@{select\+Where}}
\index{select\+Where@{select\+Where}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where()}
{\footnotesize\ttfamily std\+::string select\+Where (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Anzeigen bestimmter Datensätze mit dem Zusatz der Where-\/\+Clause. 

Mithilfe der \char`\"{}select\+Where\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{};\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a7caa0e0e66c9c4cadc4ec5d596bba565_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_ade3cc06b3d1ac3dc344ec9f606290468}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where\+One\+Column@{select\+Where\+One\+Column}}
\index{select\+Where\+One\+Column@{select\+Where\+One\+Column}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where\+One\+Column()}
{\footnotesize\ttfamily std\+::string select\+Where\+One\+Column (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value }\end{DoxyParamCaption})}



Bestimmte Datensätze von bestimmten Spalten abfragen. 

Mithilfe der \char`\"{}select\+One\+Column\char`\"{} Methode werden S\+Q\+L-\/\+Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt.~\newline
 Es wird nur die Spalte angzeigt, wo der Datensatz verglichen worden ist.~\newline


S\+Q\+L-\/\+Befehl\+: \char`\"{}\+S\+E\+L\+E\+C\+T $\ast$ F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \char`\"{} + \char`\"{}\textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{};\char`\"{} ~\newline



\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em condition\+Column} & = Enthält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & = Enthält den Bedingungswert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_ade3cc06b3d1ac3dc344ec9f606290468_cgraph}
\end{center}
\end{figure}
\mbox{\label{selection_request_8cpp_a1985a11967a7cbb2a2b38416fc6ffad5}} 
\index{selection\+Request.\+cpp@{selection\+Request.\+cpp}!select\+Where\+Order\+By@{select\+Where\+Order\+By}}
\index{select\+Where\+Order\+By@{select\+Where\+Order\+By}!selection\+Request.\+cpp@{selection\+Request.\+cpp}}
\subsubsection{select\+Where\+Order\+By()}
{\footnotesize\ttfamily std\+::string select\+Where\+Order\+By (\begin{DoxyParamCaption}\item[{std\+::string}]{table\+Name,  }\item[{std\+::vector$<$ std\+::string $>$}]{columns,  }\item[{std\+::string}]{condition\+Column,  }\item[{std\+::string}]{condition\+Value,  }\item[{std\+::string}]{to\+Sortcolumn\+Name,  }\item[{std\+::string}]{sort\+By }\end{DoxyParamCaption})}



Abfrage von Spalten mit Sortierung. 

Mithilfe der \char`\"{}select\+Where\+Order\+By\char`\"{} Methode werden die S\+QL Abfragen nur bestimmter Datensätze in einer bestimmten Spalten abgefragt. Es werden die Spalten angezeigt, die der Nutzer in dem Vektor übergeben hat. Zudem wird es Aufsteigend oder Absteigend sortiert.

S\+Q\+L-\/\+Befehl für A\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} A\+S\+C;\char`\"{} S\+Q\+L-\/\+Befehl für D\+E\+SC\+: \char`\"{}\+S\+E\+L\+E\+C\+T \char`\"{} + all\+Columns + \char`\"{} F\+R\+O\+M \char`\"{} + table\+Name + \char`\"{} W\+H\+E\+R\+E \char`\"{} + condition\+Column + \char`\"{} = \textquotesingle{}\char`\"{} + condition\+Value + \char`\"{}\textquotesingle{}\char`\"{} + \char`\"{} O\+R\+D\+E\+R B\+Y \char`\"{} + to\+Sortcolumn\+Name + \char`\"{} D\+E\+S\+C;\char`\"{}


\begin{DoxyParams}{Parameter}
{\em table\+Name} & = Name der Tabelle \\
\hline
{\em columns} & = Enthält die Liste der angezeigten Spalten \\
\hline
{\em condition\+Column} & = Enhält den Namen der Bedingungsspalte \\
\hline
{\em condition\+Value} & =Enhält den Bedingungswert \\
\hline
{\em to\+Sort\+Column\+Name} & =Enhält die Spalte zu der sotiert werden soll \\
\hline
{\em Sort\+By} & = Gibt an ob es Aufsteigend bzw Absteigend sotoiert werden soll\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Rückgabe}
string 
\end{DoxyReturn}
Hier ist ein Graph, der zeigt, was diese Funktion aufruft\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{selection_request_8cpp_a1985a11967a7cbb2a2b38416fc6ffad5_cgraph}
\end{center}
\end{figure}
